<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Komorebi</title>
    
    <!-- Google Fonts - Inter for a clean, modern look -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;500;700&display=swap" rel="stylesheet">
    
    <style>
        /* CSS Variables for Theming and Animation */
        :root {
            /* Default Dawn Theme Palette */
            --color-bg-1: #F4E9E2; /* Light background */
            --color-bg-2: #E9D8D0; /* Slightly darker background */
            --color-shape-1: #D6C2B9; /* Neutral shape color */
            --color-shape-2: #E1A691; /* Accent/control color */
            --color-text-primary: #5C4B44; /* Dark primary text */
            --color-text-secondary: #8E7C74; /* Muted secondary text */
            --color-shadow: rgba(92, 75, 68, 0.1); /* Soft shadow */
            --color-bloom: #E1A691; /* Color for theme transition bloom */

            /* Animation Timings */
            --timing-fast: 300ms;
            --timing-med: 600ms;
            --timing-slow: 1200ms;

            /* Animation Easing Functions */
            --easing-standard: cubic-bezier(0.4, 0, 0.2, 1); /* Standard material design easing */
            --easing-bloom: cubic-bezier(0.22, 1, 0.36, 1); /* More bouncy/expressive easing for bloom */
        }

        /* Base Styles */
        * { 
            box-sizing: border-box; /* Include padding and border in element's total width and height */
            margin: 0; 
            padding: 0; 
        }
        html, body { 
            height: 100%; /* Full viewport height */
            overflow: hidden; /* Prevent scrolling */
            font-family: 'Inter', sans-serif; /* Apply Inter font */
            background-color: var(--color-bg-1); /* Apply base background color */
        }
        body { 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            transition: background-color var(--timing-slow) var(--easing-standard); /* Smooth background color transition on theme change */
        }

        /* Parallax Layers */
        .parallax-layer { 
            position: fixed; /* Fixed position relative to viewport */
            will-change: transform; /* Hint to browser for performance optimization */
            transition: transform 100ms linear; /* Smooth parallax movement */
        }

        /* Background Canvas Layer (for subtle gradients and drift) */
        #background-canvas { 
            top: -50%; 
            left: -50%; 
            width: 200%; 
            height: 200%; /* Larger than viewport to allow for drift and parallax */
            z-index: 1; 
            background: 
                radial-gradient(circle at 70% 30%, var(--color-bg-2), transparent 40%), 
                radial-gradient(circle at 30% 70%, var(--color-shape-1), transparent 40%), 
                radial-gradient(circle at 50% 50%, var(--color-bg-1), transparent 30%); /* Multiple radial gradients for depth */
            background-size: 100% 100%; 
            animation: slowDrift 45s linear infinite alternate; /* Continuous slow movement */
        }
        @keyframes slowDrift { 
            from { transform: translate(0, 0); } 
            to { transform: translate(2%, 1%); } /* Subtle drift effect */
        }
        
        /* Dust Motes Layer */
        #dust-motes { 
            position: fixed; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%; 
            z-index: 2; 
            pointer-events: none; /* Allow clicks to pass through */
        }
        .mote { 
            position: absolute; 
            background-color: var(--color-shape-1); 
            border-radius: 50%; 
            opacity: 0.5; 
            filter: blur(1.5px); /* Soft blur for a dreamy effect */
            animation: float 25s infinite linear; /* Floating animation */
            will-change: transform, opacity; 
            transition: background-color var(--timing-slow) var(--easing-standard); /* Smooth color transition */
        }
        @keyframes float { 
            0% { transform: translateX(0) translateY(0); opacity: 0.5; } 
            50% { transform: translateX(calc(var(--x-end) * 1px)) translateY(calc(var(--y-end) * 1px)); opacity: 0.8; } /* Move and become slightly more opaque */
            100% { transform: translateX(0) translateY(0); opacity: 0.5; } 
        }
        
        /* Geometric Pattern Layer */
        #geometric-pattern { 
            position: fixed; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%; 
            z-index: 3; 
            opacity: 0; /* Initially hidden */
            transition: opacity var(--timing-slow) var(--easing-standard); /* Smooth fade in/out */
            pointer-events: none; 
        }
        body.pattern-active #geometric-pattern { 
            opacity: 0.15; /* Visible when active */
        }
        #geometric-pattern svg { 
            width: 100%; 
            height: 100%; 
            stroke: var(--color-text-secondary); /* Pattern lines color */
        }
        
        /* Main Content Area */
        main { 
            position: relative; 
            z-index: 10; 
            text-align: center; 
            color: var(--color-text-primary); 
            animation: fadeIn 2s var(--easing-standard) forwards; /* Fade in on load */
            opacity: 0; 
            transition: color var(--timing-slow) var(--easing-standard), transform 100ms linear; /* Smooth color and parallax transition */
        }
        @keyframes fadeIn { 
            to { opacity: 1; } 
        }
        h1 { 
            font-size: 8vw; /* Responsive font size */
            font-weight: 500; 
            letter-spacing: 0.5vw; 
            text-transform: uppercase; 
            transition: transform var(--timing-slow) var(--easing-standard); /* Smooth transform transition */
        }
        p { 
            font-size: 1.5vw; 
            font-weight: 300; 
            letter-spacing: 0.2vw; 
            margin-top: 1vh; 
            color: var(--color-text-secondary); 
            transition: color var(--timing-slow) var(--easing-standard); 
        }
        #focus-prompt { 
            display: inline-block; 
            transition: opacity var(--timing-med) var(--easing-standard); /* Smooth fade for focus prompt text */
        }

        /* Control Buttons */
        .controls { 
            position: fixed; 
            bottom: 5vh; 
            left: 50%; 
            z-index: 20; 
            display: flex; 
            gap: 20px; 
            animation: fadeIn 2s 0.5s var(--easing-standard) forwards; /* Fade in after main content */
            opacity: 0; 
            transform: translateX(-50%); /* Center horizontally */
            transition: transform 100ms linear; 
        }
        .control-leaf { 
            width: 60px; 
            height: 60px; 
            cursor: pointer; 
            border-radius: 30% 70% 70% 30% / 30% 30% 70% 70%; /* Leaf-like shape */
            background: var(--color-shape-2); 
            box-shadow: 0 10px 20px -5px var(--color-shadow); 
            transition: all var(--timing-fast) var(--easing-standard); 
            display: flex; 
            justify-content: center; 
            align-items: center; 
        }
        .control-leaf:hover, .control-leaf.active { 
            transform: translateY(-8px) scale(1.05); /* Lift and slightly enlarge on hover/active */
            box-shadow: 0 18px 35px -8px var(--color-shadow); 
        }
        .control-leaf:active { 
            transform: translateY(-2px) scale(0.98); /* Press effect */
        }
        .control-leaf svg { 
            width: 28px; 
            height: 28px; 
            stroke: var(--color-bg-1); /* Icon color */
            stroke-width: 1.5; 
            fill: none; 
            stroke-linecap: round; 
            stroke-linejoin: round; 
            transition: stroke var(--timing-slow) var(--easing-standard); 
        }

        /* Theme Bloom Effect */
        #theme-bloom { 
            position: fixed; 
            z-index: 99; 
            top: 50%; 
            left: 50%; 
            width: 1px; 
            height: 1px; 
            background: var(--color-bloom); 
            border-radius: 50%; 
            transform: scale(0); /* Initially invisible */
            pointer-events: none; 
        }
        #theme-bloom.is-blooming { 
            transition: transform 1s var(--easing-bloom), background-color var(--timing-med) var(--easing-standard); /* Bloom animation */
            transform: scale(3000); /* Expand to cover screen */
        }
        
        /* Theming - Dynamic CSS Variable Updates */
        body[data-theme="dawn"] { 
            --color-bg-1: #F4E9E2; --color-bg-2: #E9D8D0; --color-shape-1: #D6C2B9; --color-shape-2: #E1A691; --color-text-primary: #5C4B44; --color-text-secondary: #8E7C74; --color-shadow: rgba(92, 75, 68, 0.1); --color-bloom: #E1A691; 
        }
        body[data-theme="dusk"] { 
            --color-bg-1: #3E415C; --color-bg-2: #2B2D42; --color-shape-1: #5C6081; --color-shape-2: #8D99AE; --color-text-primary: #EDF2F4; --color-text-secondary: #D9D9D9; --color-shadow: rgba(0, 0, 0, 0.2); --color-bloom: #8D99AE; 
        }
        body[data-theme="meadow"] { 
            --color-bg-1: #E0F2E9; --color-bg-2: #C8E6C9; --color-shape-1: #A5D6A7; --color-shape-2: #81C784; --color-text-primary: #2E7D32; --color-text-secondary: #66BB6A; --color-shadow: rgba(76, 175, 80, 0.15); --color-bloom: #81C784; 
        }

        /* --- BREATHING FOCUS MODE STYLES --- */
        @keyframes pulse {
            0% { transform: scale(1); }
            25% { transform: scale(1.03); } /* Inhale complete */
            50% { transform: scale(1.03); } /* Hold complete */
            75% { transform: scale(1); }    /* Exhale complete */
            100% { transform: scale(1); }   /* Hold complete */
        }

        body.focus-mode-active h1 {
            animation: pulse 16s infinite ease-in-out; /* Apply pulse animation to H1 */
        }

        body.focus-mode-active .controls .control-leaf {
            opacity: 0.3; /* Dim other control buttons */
            pointer-events: none; /* Disable other buttons */
        }

        body.focus-mode-active .controls #toggle-focus.active {
            opacity: 1; /* Keep focus toggle button visible */
            pointer-events: auto; /* Re-enable focus toggle button */
        }
        
        #dust-motes.is-holding .mote {
            animation-play-state: paused; /* Pause mote animation during "Hold" phase */
        }
        /* --- END FOCUS MODE STYLES --- */

        /* Responsive Adjustments for Smaller Screens */
        @media (max-width: 768px) {
            h1 { font-size: 14vw; } /* Larger font for mobile H1 */
            p { font-size: 3vw; letter-spacing: 0.3vw; } /* Larger font for mobile paragraph */
            .control-leaf { width: 50px; height: 50px; } /* Smaller control buttons */
            .control-leaf svg { width: 24px; height: 24px; } /* Smaller icons */
        }
    </style>
</head>
<body data-theme="dawn">

    <!-- Parallax Layer: Background Canvas with Gradients -->
    <div id="background-canvas" class="parallax-layer"></div>
    
    <!-- Parallax Layer: Dust Motes Container -->
    <div id="dust-motes"></div>
    
    <!-- Geometric Pattern Layer (initially hidden) -->
    <div id="geometric-pattern">
        <svg width="100%" height="100%" xmlns="http://www.w3.org/2000/svg">
            <defs>
                <!-- Define a pattern of dots -->
                <pattern id="dot-pattern" x="0" y="0" width="20" height="20" patternUnits="userSpaceOnUse">
                    <circle cx="2" cy="2" r="1" fill="currentColor"/>
                </pattern>
            </defs>
            <!-- Apply the dot pattern to a full-size rectangle -->
            <rect width="100%" height="100%" fill="url(#dot-pattern)" />
        </svg>
    </div>

    <!-- Main Content Layer -->
    <main class="parallax-layer">
        <h1>Komorebi</h1>
        <p><span id="focus-prompt">A space for quiet thought</span></p>
    </main>

    <!-- Control Buttons Layer -->
    <div class="controls parallax-layer">
        <!-- Theme Buttons -->
        <div class="control-leaf" id="theme-dawn" title="Switch to Dawn Theme" aria-label="Switch to Dawn Theme">
            <svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line></svg>
        </div>
        <div class="control-leaf" id="theme-dusk" title="Switch to Dusk Theme" aria-label="Switch to Dusk Theme">
            <svg viewBox="0 0 24 24"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg>
        </div>
        <div class="control-leaf" id="theme-meadow" title="Switch to Meadow Theme" aria-label="Switch to Meadow Theme">
            <svg viewBox="0 0 24 24"><path d="M20.9 10.1a9.3 9.3 0 0 0-8.8-8.8A9.3 9.3 0 0 0 3.1 10.1c0 5.1 4.2 9.3 9.3 9.3s9.3-4.2 9.3-9.3z"></path><path d="M12 2v20"></path></svg>
        </div>
        
        <!-- Toggle Geometric Pattern Button -->
        <div class="control-leaf" id="toggle-pattern" title="Toggle Geometric Pattern" aria-label="Toggle Geometric Pattern">
            <svg viewBox="0 0 24 24"><rect x="3" y="3" width="7" height="7"></rect><rect x="14" y="3" width="7" height="7"></rect><rect x="14" y="14" width="7" height="7"></rect><rect x="3" y="14" width="7" height="7"></rect></svg>
        </div>
        
        <!-- Toggle Focus Mode Button -->
        <div class="control-leaf" id="toggle-focus" title="Toggle Focus Mode" aria-label="Toggle Focus Mode">
            <svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"></circle></svg>
        </div>
    </div>
    
    <!-- Theme Bloom Element (for transition effect) -->
    <div id="theme-bloom"></div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        // Get references to key DOM elements
        const body = document.body;
        const themeBloom = document.getElementById('theme-bloom');
        const parallaxLayers = document.querySelectorAll('.parallax-layer');
        const motesContainer = document.getElementById('dust-motes');
        const themeButtons = document.querySelectorAll('.controls .control-leaf[id^="theme-"]');
        const togglePatternButton = document.getElementById('toggle-pattern');
        const focusToggleButton = document.getElementById('toggle-focus');
        const focusPromptEl = document.getElementById('focus-prompt');

        // Store original prompt text for focus mode
        const originalPromptText = focusPromptEl.textContent;
        const breathPrompts = ["Breathe In", "Hold", "Breathe Out", "Hold"];
        let breathIndex = 0; // Current index for breath prompts

        let animationFrameId = null; // For parallax animation frame
        let isFocusModeActive = false; // State for focus mode
        let focusInterval = null; // Interval for breathing prompts

        /**
         * Updates the active state of control buttons based on the current theme or pattern.
         */
        function updateControlActiveStates() {
            // Update active theme button
            const currentTheme = body.dataset.theme;
            themeButtons.forEach(button => {
                if (button.id === `theme-${currentTheme}`) {
                    button.classList.add('active');
                } else {
                    button.classList.remove('active');
                }
            });

            // Update active state of pattern toggle button
            if (body.classList.contains('pattern-active')) {
                togglePatternButton.classList.add('active');
            } else {
                togglePatternButton.classList.remove('active');
            }

            // Update focus toggle button state (handled by toggleFocusMode itself)
        }

        // --- PARALLAX EFFECT ---
        /**
         * Handles mouse and touch movements to create a parallax effect on specified layers.
         * @param {Object} coords - Object containing clientX and clientY coordinates.
         */
        function handleParallaxMove(coords) {
            // Disable parallax if focus mode is active
            if (isFocusModeActive) return; 

            // Cancel any pending animation frame to ensure only one is active
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            
            animationFrameId = requestAnimationFrame(() => {
                const { clientX, clientY } = coords;
                // Calculate normalized coordinates (-0.5 to 0.5) relative to viewport center
                const x = (clientX / window.innerWidth) - 0.5;
                const y = (clientY / window.innerHeight) - 0.5;

                // Multipliers for different layers to create depth
                const multipliers = { 
                    'background-canvas': 30, // Moves fastest
                    'main': -10,             // Moves slower, in opposite direction
                    'controls': -5           // Moves slowest, in opposite direction
                };

                // Apply transform to each parallax layer
                parallaxLayers.forEach(layer => {
                    // Determine multiplier based on layer ID or first class name
                    const multiplier = multipliers[layer.id] || multipliers[layer.className.split(' ')[0]];
                    if (layer.style) {
                        layer.style.transform = `translateX(${x * multiplier}px) translateY(${y * multiplier}px)`;
                    }
                });
            });
        }

        // Event listeners for parallax
        window.addEventListener('mousemove', handleParallaxMove);
        window.addEventListener('touchmove', (e) => {
            // Check if there are touches to prevent errors
            if (e.touches.length > 0) {
                handleParallaxMove(e.touches[0]);
            }
        }, { passive: true }); // Use passive listener for better scroll performance

        // --- THEME BLOOM EFFECT ---
        /**
         * Triggers a visual "bloom" effect when switching themes.
         * @param {string} newTheme - The ID of the new theme to switch to.
         * @param {MouseEvent} event - The click event that triggered the theme change.
         */
        function triggerThemeBloom(newTheme, event) {
            // Set the bloom element's position to the click coordinates
            themeBloom.style.left = `${event.clientX}px`;
            themeBloom.style.top = `${event.clientY}px`;

            // Reset bloom scale and remove blooming class to re-trigger animation
            themeBloom.classList.remove('is-blooming');
            themeBloom.style.transform = 'scale(0)'; // Ensure it starts from 0

            // Force reflow to restart animation
            void themeBloom.offsetWidth; 

            // Add blooming class to start the animation
            themeBloom.classList.add('is-blooming');

            // After the bloom animation starts, change the theme
            // Delay theme change slightly to let bloom cover the screen
            setTimeout(() => {
                body.dataset.theme = newTheme;
                updateControlActiveStates(); // Update active state after theme change
            }, varCssToMs('--timing-fast')); // Match with the fast timing for a quick transition

            // Remove blooming class after animation completes to reset for next bloom
            themeBloom.addEventListener('transitionend', () => {
                themeBloom.classList.remove('is-blooming');
                themeBloom.style.transform = 'scale(0)'; // Reset size
            }, { once: true }); // Ensure this listener runs only once
        }

        /**
         * Helper function to convert CSS variable timing to milliseconds.
         * @param {string} varName - The name of the CSS variable (e.g., '--timing-fast').
         * @returns {number} The time in milliseconds.
         */
        function varCssToMs(varName) {
            const value = getComputedStyle(document.documentElement).getPropertyValue(varName);
            return parseFloat(value) || 0; // Return 0 if parsing fails
        }

        // Event listeners for theme buttons
        themeButtons.forEach(button => {
            button.addEventListener('click', (event) => {
                const newTheme = button.id.replace('theme-', '');
                triggerThemeBloom(newTheme, event);
            });
        });

        // --- PATTERN TOGGLE ---
        /**
         * Toggles the geometric pattern visibility.
         */
        function toggleGeometricPattern() {
            body.classList.toggle('pattern-active');
            updateControlActiveStates(); // Update active state of button
        }

        // Event listener for pattern toggle button
        togglePatternButton.addEventListener('click', toggleGeometricPattern);

        // --- DUST MOTES GENERATION ---
        const numMotes = 30; // Number of dust motes to generate
        for (let i = 0; i < numMotes; i++) {
            const mote = document.createElement('div');
            mote.className = 'mote';
            const size = Math.random() * 3 + 1; // Random size between 1px and 4px
            mote.style.width = `${size}px`; 
            mote.style.height = `${size}px`;
            mote.style.left = `${Math.random() * 100}%`; // Random horizontal position
            mote.style.top = `${Math.random() * 100}%`; // Random vertical position
            mote.style.animationDuration = `${Math.random() * 20 + 15}s`; // Random animation duration
            mote.style.animationDelay = `${Math.random() * 10}s`; // Random animation delay
            // Custom CSS properties for animation keyframes
            mote.style.setProperty('--x-end', Math.random() * 200 - 100); 
            mote.style.setProperty('--y-end', Math.random() * 200 - 100);
            motesContainer.appendChild(mote);
        }

        // --- BREATHING FOCUS MODE LOGIC ---
        /**
         * Toggles the breathing focus mode on and off.
         */
        function toggleFocusMode() {
            isFocusModeActive = !isFocusModeActive;
            body.classList.toggle('focus-mode-active', isFocusModeActive);
            focusToggleButton.classList.toggle('active', isFocusModeActive);

            if (isFocusModeActive) {
                // --- Activate Focus Mode ---
                breathIndex = 0; // Reset breath prompt index
                
                /**
                 * Updates the breathing prompt text and controls mote animation.
                 */
                const updatePrompt = () => {
                    focusPromptEl.style.opacity = '0'; // Fade out current prompt
                    setTimeout(() => {
                        const currentPrompt = breathPrompts[breathIndex];
                        focusPromptEl.textContent = currentPrompt; // Set new prompt
                        focusPromptEl.style.opacity = '1'; // Fade in new prompt

                        // Pause motes during "Hold" phases
                        motesContainer.classList.toggle('is-holding', currentPrompt === "Hold");

                        // Move to the next prompt
                        breathIndex = (breathIndex + 1) % breathPrompts.length;
                    }, 500); // Wait for fade out transition (matching CSS)
                };
                
                updatePrompt(); // Initial call to display first prompt
                focusInterval = setInterval(updatePrompt, 4000); // Cycle prompts every 4 seconds
            } else {
                // --- Deactivate Focus Mode ---
                if (focusInterval) {
                    clearInterval(focusInterval); // Stop the breathing prompt interval
                }
                focusInterval = null;
                motesContainer.classList.remove('is-holding'); // Resume mote animation
                focusPromptEl.style.opacity = '0'; // Fade out current prompt
                setTimeout(() => {
                    focusPromptEl.textContent = originalPromptText; // Restore original prompt
                    focusPromptEl.style.opacity = '1'; // Fade in original prompt
                }, 500); // Wait for fade out transition
            }
        }
        
        // Event listener for focus mode toggle button
        focusToggleButton.addEventListener('click', toggleFocusMode);

        // Allow clicking anywhere on the background to exit focus mode
        document.getElementById('background-canvas').addEventListener('click', () => {
            if (isFocusModeActive) {
                toggleFocusMode();
            }
        });

        // Initial setup: Set active state for the current theme on load
        updateControlActiveStates();
    });
    </script>
</body>
</html>

