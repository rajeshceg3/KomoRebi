<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Komorebi</title>
    
    <!-- Google Fonts - Inter for a clean, modern look -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;500;700&display=swap" rel="stylesheet">
    
    <style>
        /* CSS Variables for Theming and Animation */
        :root {
            /* Typography Scale - Fluid & Refined */
            --font-display: 'Inter', system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            --font-size-h1: clamp(3.5rem, 9vw, 7.5rem);
            --font-size-p: clamp(1.125rem, 2vw, 1.5rem);
            --font-weight-h1: 500;
            --font-weight-p: 400;

            /* Elevation & Shadows (Stripe-like multi-layer) */
            --shadow-low:
                0px 0.6px 0.7px -0.8px rgba(0, 0, 0, 0.08),
                0px 1.4px 1.6px -1.7px rgba(0, 0, 0, 0.06),
                0px 3.3px 3.7px -2.5px rgba(0, 0, 0, 0.04);
            --shadow-medium:
                0px 0.8px 0.9px -0.6px rgba(0, 0, 0, 0.08),
                0px 2px 2.3px -1.1px rgba(0, 0, 0, 0.06),
                0px 4.6px 5.3px -1.7px rgba(0, 0, 0, 0.05),
                0px 11px 12.7px -2.2px rgba(0, 0, 0, 0.03);
            --shadow-high:
                0px 0.5px 0.6px hsl(var(--shadow-color) / 0.1),
                0px 1.6px 1.8px -0.4px hsl(var(--shadow-color) / 0.1),
                0px 3.1px 3.5px -0.7px hsl(var(--shadow-color) / 0.1),
                0px 5.6px 6.4px -1.1px hsl(var(--shadow-color) / 0.1),
                0px 10px 11.4px -1.4px hsl(var(--shadow-color) / 0.1),
                0px 18px 20.5px -1.8px hsl(var(--shadow-color) / 0.1);
            --shadow-color: 240 4% 10%; /* Base HSL for shadows */

            /* Default Dawn Theme Palette - Warm, airy, premium */
            --color-bg-1: #FFFBF9;
            --color-bg-2: #F2EBE8;
            --color-shape-1: #E6D5CD;
            --color-shape-2: #D4ABA0;
            --color-text-primary: #463A34;
            --color-text-secondary: #8A7A72;
            --color-accent: #D4ABA0;
            --color-dock-bg: rgba(255, 251, 249, 0.75);
            --color-dock-border: rgba(255, 255, 255, 0.6);
            --color-bloom: #F2DAD5;

            /* Animation Timings */
            --timing-fast: 200ms;
            --timing-med: 400ms;
            --timing-slow: 800ms;

            /* Animation Easing Functions - "Ultrathink" Smoothness */
            --easing-standard: cubic-bezier(0.25, 0.1, 0.25, 1.0);
            --easing-out: cubic-bezier(0.16, 1, 0.3, 1); /* Apple-like ease-out */
            --easing-in: cubic-bezier(0.7, 0, 0.84, 0);
            --easing-elastic: cubic-bezier(0.5, 1.25, 0.25, 1.15); /* Subtle bounce */
        }

        /* Base Styles */
        * { 
            box-sizing: border-box;
            margin: 0; 
            padding: 0; 
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            -webkit-tap-highlight-color: transparent;
        }
        html, body { 
            height: 100%;
            height: 100dvh; /* Dynamic Viewport Height for mobile */
            overflow: hidden;
            font-family: var(--font-display);
            background-color: var(--color-bg-1);
        }
        body { 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            transition: background-color var(--timing-slow) var(--easing-standard);
        }

        /* Noise Overlay for Texture (Ultra-fine grain) */
        #noise-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 90;
            pointer-events: none;
            opacity: 0.03; /* Subtler */
            /* Higher frequency noise for premium feel */
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.8' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)' opacity='1'/%3E%3C/svg%3E");
            mix-blend-mode: overlay;
        }

        /* Parallax Layers */
        .parallax-layer { 
            position: fixed;
            will-change: transform;
            /* Removed linear transition for direct JS control (smoother) */
            /* transform-style: preserve-3d; */
        }

        /* Background Canvas Layer (Mesh Gradient) */
        #background-canvas { 
            top: -50%; 
            left: -50%; 
            width: 200%; 
            height: 200%;
            z-index: 1; 
            background-color: var(--color-bg-1);
            background-image:
                radial-gradient(at 0% 0%, var(--color-bg-2) 0px, transparent 50%),
                radial-gradient(at 100% 0%, var(--color-shape-1) 0px, transparent 50%),
                radial-gradient(at 100% 100%, var(--color-shape-2) 0px, transparent 50%),
                radial-gradient(at 0% 100%, var(--color-bg-2) 0px, transparent 50%),
                radial-gradient(at 50% 50%, var(--color-bg-1) 0px, transparent 50%);
            background-size: 120% 120%;
            animation: meshFlow 60s ease-in-out infinite alternate;
            opacity: 0.8;
        }
        @keyframes meshFlow {
            0% { transform: translate(0, 0) scale(1); }
            100% { transform: translate(2%, 1%) scale(1.05); }
        }
        
        /* Dust Motes Layer */
        #dust-motes { 
            position: fixed; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%; 
            z-index: 2; 
            pointer-events: none;
        }
        .mote { 
            position: absolute; 
            background-color: var(--color-shape-1); 
            border-radius: 50%; 
            opacity: 0.4;
            filter: blur(1.5px); /* Softer blur */
            animation: float 25s infinite ease-in-out alternate; /* smoother motion */
            will-change: transform, opacity; 
            transition: background-color var(--timing-slow) var(--easing-standard);
        }
        @keyframes float { 
            0% { transform: translate(0, 0); opacity: 0.3; }
            100% { transform: translate(calc(var(--x-end) * 1px), calc(var(--y-end) * 1px)); opacity: 0.7; }
        }
        
        /* Geometric Pattern Layer */
        #geometric-pattern { 
            position: fixed; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%; 
            z-index: 3; 
            opacity: 0; /* Initially hidden */
            transition: opacity var(--timing-slow) var(--easing-standard); /* Smooth fade in/out */
            pointer-events: none; 
        }
        body.pattern-active #geometric-pattern { 
            opacity: 0.15; /* Visible when active */
        }
        #geometric-pattern svg { 
            width: 100%; 
            height: 100%; 
            stroke: var(--color-text-secondary); /* Pattern lines color */
        }
        
        /* Main Content Area */
        main { 
            position: relative; 
            z-index: 10; 
            text-align: center; 
            color: var(--color-text-primary); 
            animation: fadeIn 2s var(--easing-standard) forwards; /* Fade in on load */
            opacity: 0; 
            transition: color var(--timing-slow) var(--easing-standard), transform 100ms linear; /* Smooth color and parallax transition */
        }
        @keyframes fadeIn { 
            to { opacity: 1; } 
        }
        h1 { 
            font-size: var(--font-size-h1);
            font-weight: 500; 
            letter-spacing: -0.02em; /* Tighter tracking for modern look */
            line-height: 1.1;
            text-transform: none; /* Removed uppercase for a more relaxed feel */
            transition: transform var(--timing-slow) var(--easing-standard);
        }
        p { 
            font-size: var(--font-size-p);
            font-weight: 400;
            letter-spacing: 0.01em;
            margin-top: 1.5vh;
            color: var(--color-text-secondary); 
            transition: color var(--timing-slow) var(--easing-standard); 
        }
        #focus-prompt { 
            display: inline-block; 
            transition: opacity var(--timing-med) var(--easing-standard); /* Smooth fade for focus prompt text */
        }

        /* Control Dock */
        .controls { 
            position: fixed; 
            bottom: 3rem;
            left: 50%; 
            z-index: 20; 
            display: flex; 
            align-items: center;
            gap: 8px;
            padding: 6px 8px;
            border-radius: 9999px; /* Pill shape */
            background: var(--color-dock-bg);
            backdrop-filter: blur(24px) saturate(180%); /* Enhanced glass effect */
            -webkit-backdrop-filter: blur(24px) saturate(180%);
            border: 1px solid var(--color-dock-border);
            box-shadow:
                var(--shadow-medium),
                inset 0 0 0 1px rgba(255, 255, 255, 0.15); /* Inner glimmer */
            animation: fadeInUp 1.2s var(--easing-out) forwards;
            opacity: 0; 
            /* Transform is handled by JS for tilt effect, initial state set here */
            transform: perspective(1000px) rotateX(0) rotateY(0) translateX(-50%) translateY(20px);
            transition: opacity 0.5s ease, box-shadow 0.3s ease; /* Removed transform transition for instant JS updates */
            will-change: transform;
        }

        @keyframes fadeInUp {
            to { opacity: 1; transform: perspective(1000px) rotateX(0) rotateY(0) translateX(-50%) translateY(0); }
        }

        .control-group {
            display: flex;
            gap: 4px;
            padding: 0 6px;
            border-right: 1px solid var(--color-dock-border);
        }
        .control-group:last-child {
            border-right: none;
        }

        .control-btn {
            position: relative;
            width: 40px;
            height: 40px;
            cursor: pointer; 
            border-radius: 50%; /* Circle for more modern look */
            background: transparent;
            display: flex; 
            justify-content: center; 
            align-items: center; 
            color: var(--color-text-secondary);
            transition: all var(--timing-fast) var(--easing-standard);
        }

        /* Desktop Hover State */
        @media (hover: hover) {
            .control-btn:hover {
                background-color: rgba(255, 255, 255, 0.4);
                color: var(--color-text-primary);
                transform: translateY(-2px);
                box-shadow: var(--shadow-low);
            }
        }

        .control-btn.active {
            background-color: var(--color-text-primary);
            color: var(--color-bg-1);
            box-shadow: var(--shadow-medium);
        }
        .control-btn:active {
            transform: scale(0.95);
        }

        .control-btn svg {
            width: 20px;
            height: 20px;
            stroke: currentColor;
            stroke-width: 2;
            fill: none; 
            stroke-linecap: round; 
            stroke-linejoin: round; 
            transition: all 0.2s ease;
        }

        /* Tooltips */
        .control-btn::after {
            content: attr(aria-label);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%) translateY(-8px) scale(0.95);
            padding: 6px 10px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            font-size: 12px;
            border-radius: 6px;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: all 0.2s cubic-bezier(0.2, 0.8, 0.2, 1);
            z-index: 100;
            margin-bottom: 8px;
            font-weight: 500;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }

        .control-btn:hover::after {
            opacity: 1;
            transform: translateX(-50%) translateY(0) scale(1);
        }

        /* Theme Bloom Effect */
        #theme-bloom { 
            position: fixed; 
            z-index: 99; 
            top: 50%; 
            left: 50%; 
            width: 1px; 
            height: 1px; 
            background: var(--color-bloom); 
            border-radius: 50%; 
            transform: scale(0); /* Initially invisible */
            pointer-events: none; 
        }
        #theme-bloom.is-blooming { 
            transition: transform 1s var(--easing-bloom), background-color var(--timing-med) var(--easing-standard); /* Bloom animation */
            transform: scale(3000); /* Expand to cover screen */
        }
        
        /* Theming - Refined Palettes */
        body[data-theme="dawn"] { 
            --color-bg-1: #FFFBF9;
            --color-bg-2: #F6EFEC;
            --color-shape-1: #EBE0DC;
            --color-shape-2: #DCC8C0;
            --color-text-primary: #4A3C35;
            --color-text-secondary: #94857D;
            --color-accent: #E6A08D;
            --color-bloom: #FFEEE8;
            --color-light-ray: rgba(255, 230, 210, 0.35);
            --color-dock-bg: rgba(255, 251, 249, 0.8);
            --color-dock-border: rgba(255, 255, 255, 0.6);
            --shadow-color: 25 10% 20%;
        }
        body[data-theme="dusk"] { 
            --color-bg-1: #0F111A;
            --color-bg-2: #161824;
            --color-shape-1: #23263A;
            --color-shape-2: #4B527E;
            --color-text-primary: #E8EAED;
            --color-text-secondary: #8F94A8;
            --color-accent: #7A81A8;
            --color-bloom: #2A2D3D;
            --color-light-ray: rgba(180, 220, 255, 0.08);
            --color-dock-bg: rgba(20, 22, 30, 0.7);
            --color-dock-border: rgba(255, 255, 255, 0.08);
            --shadow-color: 230 20% 5%;
        }
        body[data-theme="meadow"] { 
            --color-bg-1: #F4F9F6;
            --color-bg-2: #E8F2EC;
            --color-shape-1: #D1E6DA;
            --color-shape-2: #A5C9B3;
            --color-text-primary: #25382B;
            --color-text-secondary: #657D6E;
            --color-accent: #88BBA0;
            --color-bloom: #E0F0E6;
            --color-light-ray: rgba(220, 255, 230, 0.2);
            --color-dock-bg: rgba(244, 249, 246, 0.8);
            --color-dock-border: rgba(255, 255, 255, 0.6);
            --shadow-color: 150 15% 15%;
        }

        /* --- LIGHT RAYS --- */
        #light-rays {
            position: fixed;
            top: -20%;
            left: -20%;
            width: 140%;
            height: 140%;
            z-index: 4;
            pointer-events: none;
            opacity: 0;
            --ray-color: var(--color-light-ray);
            /* Complex multi-layered rays */
            background:
                repeating-conic-gradient(
                    from 0deg at 50% -10%,
                    transparent 0deg,
                    var(--ray-color) 10deg,
                    transparent 20deg
                );
            mask-image: radial-gradient(ellipse at 50% 0%, black 40%, transparent 80%);
            -webkit-mask-image: radial-gradient(ellipse at 50% 0%, black 40%, transparent 80%);
            filter: blur(60px);
            mix-blend-mode: overlay;
            transition: opacity var(--timing-slow) var(--easing-standard);
            animation: rayRotate 60s linear infinite;
        }

        body.light-rays-active #light-rays {
            opacity: 1;
        }

        @keyframes rayRotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(5deg); }
        }
        /* --- END LIGHT RAYS --- */

        /* --- BREATHING FOCUS MODE STYLES --- */
        @keyframes pulse {
            0% { transform: scale(1); }
            25% { transform: scale(1.03); } /* Inhale complete */
            50% { transform: scale(1.03); } /* Hold complete */
            75% { transform: scale(1); }    /* Exhale complete */
            100% { transform: scale(1); }   /* Hold complete */
        }

        body.focus-mode-active h1 {
            opacity: 0.5;
            transform: scale(0.95);
        }

        /* Breathing Ring Visualization */
        #breathing-ring {
            position: fixed;
            top: 50%;
            left: 50%;
            width: 300px;
            height: 300px;
            border-radius: 50%;
            border: 1px solid var(--color-shape-2);
            transform: translate(-50%, -50%) scale(0.8);
            opacity: 0;
            pointer-events: none;
            z-index: 5;
            transition: opacity 0.8s ease;
        }

        /* Inner fill */
        #breathing-ring::before {
            content: '';
            position: absolute;
            inset: 0;
            border-radius: 50%;
            background: var(--color-shape-2);
            opacity: 0.05;
            transform: scale(0.8);
            transition: transform 0.1s;
        }

        /* Outer echo ring */
        #breathing-ring::after {
            content: '';
            position: absolute;
            inset: -20px;
            border-radius: 50%;
            border: 1px solid var(--color-shape-2);
            opacity: 0;
            transform: scale(0.9);
        }

        body.focus-mode-active #breathing-ring {
            opacity: 1;
            animation: breatheMain 16s infinite cubic-bezier(0.4, 0.0, 0.2, 1);
        }

        body.focus-mode-active #breathing-ring::after {
            animation: breatheEcho 16s infinite cubic-bezier(0.4, 0.0, 0.2, 1);
        }

        @keyframes breatheMain {
            0% { transform: translate(-50%, -50%) scale(0.8); border-color: color-mix(in srgb, var(--color-shape-2), transparent 70%); }
            25% { transform: translate(-50%, -50%) scale(1.15); border-color: var(--color-shape-2); } /* Inhale */
            50% { transform: translate(-50%, -50%) scale(1.15); } /* Hold */
            75% { transform: translate(-50%, -50%) scale(0.8); border-color: color-mix(in srgb, var(--color-shape-2), transparent 70%); } /* Exhale */
            100% { transform: translate(-50%, -50%) scale(0.8); } /* Hold */
        }

        @keyframes breatheEcho {
            0% { transform: scale(0.9); opacity: 0; }
            25% { transform: scale(1.25); opacity: 0.3; }
            50% { transform: scale(1.25); opacity: 0.3; }
            75% { transform: scale(0.9); opacity: 0; }
            100% { transform: scale(0.9); opacity: 0; }
        }

        body.focus-mode-active .controls {
            border-color: transparent;
            background: transparent;
            box-shadow: none;
            backdrop-filter: none;
        }

        body.focus-mode-active .controls .control-group {
            border-right: none;
        }

        body.focus-mode-active .controls .control-btn {
            opacity: 0;
            pointer-events: none;
            transform: translateY(20px);
        }

        body.focus-mode-active .controls #toggle-focus.active {
            opacity: 0.8;
            pointer-events: auto;
            transform: translateY(0);
        }
        
        #dust-motes.is-holding .mote {
            transition: all 1s ease;
            opacity: 0.2;
        }
        /* --- END FOCUS MODE STYLES --- */

        /* --- ENTRAINMENT (BRAINWAVE) MODULE STYLES --- */
        #entrainment-menu {
            position: absolute;
            bottom: 140%; /* Above the dock with some spacing */
            left: 50%;
            transform: translateX(-50%) translateY(10px) scale(0.95);
            display: flex;
            gap: 16px;
            padding: 16px 20px;
            background: var(--color-dock-bg);
            backdrop-filter: blur(24px) saturate(180%);
            -webkit-backdrop-filter: blur(24px) saturate(180%);
            border: 1px solid var(--color-dock-border);
            border-radius: 24px;
            box-shadow: var(--shadow-medium);
            opacity: 0;
            pointer-events: none;
            transition: all 0.3s cubic-bezier(0.16, 1, 0.3, 1);
            z-index: 19; /* Below dock z-index(20) but above content */
        }

        #entrainment-menu.active {
            opacity: 1;
            pointer-events: auto;
            transform: translateX(-50%) translateY(0) scale(1);
        }

        .entrainment-option {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            width: 52px;
            position: relative;
        }

        .entrainment-icon {
            width: 44px;
            height: 44px;
            border-radius: 50%;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s cubic-bezier(0.25, 0.1, 0.25, 1.0);
            color: var(--color-text-secondary);
            font-size: 14px;
            font-weight: 700;
        }

        .entrainment-label {
            font-size: 10px;
            font-weight: 600;
            color: var(--color-text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            opacity: 0.7;
            transition: all 0.2s ease;
        }

        .entrainment-hz {
            font-size: 9px;
            opacity: 0.5;
            margin-top: -4px;
        }

        @media (hover: hover) {
            .entrainment-option:hover .entrainment-icon {
                background: rgba(255,255,255,0.4);
                transform: translateY(-2px);
                color: var(--color-text-primary);
                border-color: rgba(255,255,255,0.5);
            }
            .entrainment-option:hover .entrainment-label {
                opacity: 1;
                color: var(--color-text-primary);
            }
        }

        .entrainment-option.active .entrainment-icon {
            background: var(--color-text-primary);
            color: var(--color-bg-1);
            border-color: transparent;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            transform: translateY(-1px);
        }

        .entrainment-option.active .entrainment-label {
             color: var(--color-text-primary);
             font-weight: 700;
             opacity: 1;
        }

        /* Visual Entrainment Overlay - Subtle strobe */
        #entrainment-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at 50% 50%, var(--color-shape-1), transparent 70%);
            pointer-events: none;
            z-index: 80; /* Below noise(90) */
            opacity: 0;
            mix-blend-mode: screen;
            transition: opacity 0.5s ease;
        }
        /* --- END ENTRAINMENT MODULE STYLES --- */

        /* Responsive Adjustments for Mobile */
        @media (max-width: 768px) {
            /* Typography optimizations for portrait reading */
            h1 {
                font-size: 14vw;
                line-height: 1.1;
                margin-bottom: 1rem;
            }
            p {
                font-size: 1.125rem;
                letter-spacing: 0.01em;
                padding: 0 20px;
                max-width: 300px;
                margin-left: auto;
                margin-right: auto;
            }

            /* Enhanced Touch Targets for Mobile */
            .controls {
                bottom: 2.5rem; /* Raise slightly above home indicator */
                padding: 8px 10px;
                gap: 6px;
                /* Optimize glass effect for mobile performance */
                backdrop-filter: blur(16px) saturate(160%);
                -webkit-backdrop-filter: blur(16px) saturate(160%);
                width: auto;
                max-width: 90vw;
            }

            .control-btn {
                width: 48px; /* Standard 48px touch target */
                height: 48px;
            }

            .control-btn svg {
                width: 24px;
                height: 24px;
            }

            .control-group {
                padding: 0 6px;
                gap: 8px;
            }

            /* Disable tooltip on mobile to prevent sticky states */
            .control-btn::after {
                display: none;
            }

            /* Simplify complex effects for battery/performance */
            #background-canvas {
                animation: meshFlow 80s ease-in-out infinite alternate; /* Slower animation */
            }

            /* Ensure noise is subtle on high-density screens */
            #noise-overlay {
                opacity: 0.04;
            }
        }

        /* Touch-specific interaction refinements */
        @media (hover: none) and (pointer: coarse) {
            .control-btn:active {
                transform: scale(0.92); /* More feedback on touch */
                background-color: rgba(255, 255, 255, 0.2);
            }
        }
    </style>
</head>
<body data-theme="dawn">

    <!-- Parallax Layer: Background Canvas with Gradients -->
    <div id="background-canvas" class="parallax-layer"></div>
    
    <!-- Parallax Layer: Dust Motes Container -->
    <div id="dust-motes"></div>
    
    <!-- Light Rays Layer -->
    <div id="light-rays"></div>

    <!-- Noise Overlay -->
    <div id="noise-overlay"></div>

    <!-- Visual Entrainment Overlay -->
    <div id="entrainment-overlay"></div>

    <!-- Geometric Pattern Layer (initially hidden) -->
    <div id="geometric-pattern">
        <svg width="100%" height="100%" xmlns="http://www.w3.org/2000/svg">
            <defs>
                <!-- Define a pattern of dots -->
                <pattern id="dot-pattern" x="0" y="0" width="20" height="20" patternUnits="userSpaceOnUse">
                    <circle cx="2" cy="2" r="1" fill="currentColor"/>
                </pattern>
            </defs>
            <!-- Apply the dot pattern to a full-size rectangle -->
            <rect width="100%" height="100%" fill="url(#dot-pattern)" />
        </svg>
    </div>

    <!-- Main Content Layer -->
    <main class="parallax-layer">
        <h1>Komorebi</h1>
        <p><span id="focus-prompt">A space for quiet thought</span></p>
    </main>

    <!-- Breathing Ring -->
    <div id="breathing-ring"></div>

    <!-- Control Buttons Layer -->
    <div class="controls parallax-layer">
        <!-- Theme Buttons Group -->
        <!-- Entrainment Menu (Pop-up) -->
        <div id="entrainment-menu">
            <div class="entrainment-option" data-mode="gamma">
                <div class="entrainment-icon" style="color: #FFD700;">G</div>
                <div class="entrainment-label">Focus</div>
                <div class="entrainment-hz">40Hz</div>
            </div>
            <div class="entrainment-option" data-mode="beta">
                <div class="entrainment-icon" style="color: #00BFFF;">B</div>
                <div class="entrainment-label">Alert</div>
                <div class="entrainment-hz">20Hz</div>
            </div>
            <div class="entrainment-option" data-mode="alpha">
                <div class="entrainment-icon" style="color: #32CD32;">A</div>
                <div class="entrainment-label">Flow</div>
                <div class="entrainment-hz">10Hz</div>
            </div>
            <div class="entrainment-option" data-mode="theta">
                <div class="entrainment-icon" style="color: #9370DB;">T</div>
                <div class="entrainment-label">Dream</div>
                <div class="entrainment-hz">5Hz</div>
            </div>
        </div>

        <div class="control-group">
            <div class="control-btn" id="theme-dawn" aria-label="Dawn">
                <svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line></svg>
            </div>
            <div class="control-btn" id="theme-dusk" aria-label="Dusk">
                <svg viewBox="0 0 24 24"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg>
            </div>
            <div class="control-btn" id="theme-meadow" aria-label="Meadow">
                <svg viewBox="0 0 24 24"><path d="M20.9 10.1a9.3 9.3 0 0 0-8.8-8.8A9.3 9.3 0 0 0 3.1 10.1c0 5.1 4.2 9.3 9.3 9.3s9.3-4.2 9.3-9.3z"></path><path d="M12 2v20"></path></svg>
            </div>
        </div>
        
        <!-- Features Group -->
        <div class="control-group">
            <div class="control-btn" id="toggle-pattern" aria-label="Patterns">
                <svg viewBox="0 0 24 24"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><circle cx="8.5" cy="8.5" r="1.5"></circle><circle cx="15.5" cy="8.5" r="1.5"></circle><circle cx="15.5" cy="15.5" r="1.5"></circle><circle cx="8.5" cy="15.5" r="1.5"></circle></svg>
            </div>

            <div class="control-btn" id="toggle-rays" aria-label="Light Rays">
                <svg viewBox="0 0 24 24"><path d="M12 3v3m0 12v3M3 12h3m12 0h3m-2.828-6.172l-2.122 2.122m-8.1 8.1l-2.122 2.122m0-12.244l2.122 2.122m8.1 8.1l2.122 2.122M12 8a4 4 0 1 0 0 8 4 4 0 0 0 0-8z"></path></svg>
            </div>

            <div class="control-btn" id="toggle-brain" aria-label="Brainwave Entrainment">
                <svg viewBox="0 0 24 24"><path d="M9.5 2A2.5 2.5 0 0 1 12 4.5v15a2.5 2.5 0 0 1-4.96.44 2.5 2.5 0 0 1-2.96-3.08 3 3 0 0 1-.34-5.58 2.5 2.5 0 0 1 1.32-4.24 2.5 2.5 0 0 1 4.44-2A2.5 2.5 0 0 1 9.5 2Z"></path><path d="M14.5 2A2.5 2.5 0 0 0 12 4.5v15a2.5 2.5 0 0 0 4.96.44 2.5 2.5 0 0 0 2.96-3.08 3 3 0 0 0 .34-5.58 2.5 2.5 0 0 0-1.32-4.24 2.5 2.5 0 0 0-4.44-2A2.5 2.5 0 0 0 14.5 2Z"></path></svg>
            </div>

            <div class="control-btn" id="toggle-focus" aria-label="Focus Mode">
                <svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"></circle><circle cx="12" cy="12" r="3"></circle></svg>
            </div>

            <div class="control-btn" id="toggle-sound" aria-label="Sound On">
                <!-- Volume Off (Default) -->
                <svg viewBox="0 0 24 24" id="icon-sound-off"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><line x1="23" y1="9" x2="17" y2="15"></line><line x1="17" y1="9" x2="23" y2="15"></line></svg>
                <!-- Volume On (Hidden initially) -->
                <svg viewBox="0 0 24 24" id="icon-sound-on" style="display: none;"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"></path></svg>
            </div>
        </div>
    </div>
    
    <!-- Theme Bloom Element (for transition effect) -->
    <div id="theme-bloom"></div>

    <script>
    // --- ENTRAINMENT ENGINE SUB-MODULE ---
    class EntrainmentEngine {
        constructor(ctx, destination) {
            this.ctx = ctx;
            this.destination = destination;
            this.activeNodes = [];
            this.currentMode = null;
            this.gainNode = null;
            this.visualOverlay = document.getElementById('entrainment-overlay');
            this.pulseInterval = null;
            this.cleanupTimer = null;
        }

        init() {
            if (this.gainNode) return;
            this.gainNode = this.ctx.createGain();
            this.gainNode.gain.value = 0;
            this.gainNode.connect(this.destination);
        }

        setMode(modeData) {
            // Stop existing, but ensure any pending cleanup is cancelled immediately
            // so we don't kill the new nodes we are about to create.
            if (this.cleanupTimer) {
                clearTimeout(this.cleanupTimer);
                this.cleanupTimer = null;
            }
            this.stop(true);

            if (!modeData) return;
            this.init();

            const now = this.ctx.currentTime;
            this.currentMode = modeData;
            this.gainNode.gain.cancelScheduledValues(now);
            this.gainNode.gain.setValueAtTime(0, now);
            this.gainNode.gain.linearRampToValueAtTime(0.15, now + 2); // Fade in

            // Carrier Frequency (Base tone)
            const carrierFreq = modeData.carrier;
            // Beat Frequency (The difference)
            const beatFreq = modeData.rate;

            // Left Ear (Carrier)
            const oscL = this.ctx.createOscillator();
            oscL.type = 'sine';
            oscL.frequency.value = carrierFreq;

            const panL = this.ctx.createStereoPanner();
            panL.pan.value = -1; // Hard Left

            // Right Ear (Carrier + Beat)
            const oscR = this.ctx.createOscillator();
            oscR.type = 'sine';
            oscR.frequency.value = carrierFreq + beatFreq;

            const panR = this.ctx.createStereoPanner();
            panR.pan.value = 1; // Hard Right

            // Connect graph
            oscL.connect(panL);
            panL.connect(this.gainNode);

            oscR.connect(panR);
            panR.connect(this.gainNode);

            oscL.start(now);
            oscR.start(now);

            this.activeNodes.push(oscL, oscR, panL, panR);

            // Start Visual Entrainment
            this.startVisuals(beatFreq);
        }

        stop(fade = false) {
            // Cancel any pending cleanup from a previous stop call
            if (this.cleanupTimer) {
                clearTimeout(this.cleanupTimer);
                this.cleanupTimer = null;
            }

            if (this.pulseInterval) {
                clearInterval(this.pulseInterval);
                this.pulseInterval = null;
                this.visualOverlay.style.opacity = 0;
            }

            if (!this.gainNode) return;

            const now = this.ctx.currentTime;

            if (fade) {
                this.gainNode.gain.cancelScheduledValues(now);
                this.gainNode.gain.setValueAtTime(this.gainNode.gain.value, now);
                this.gainNode.gain.linearRampToValueAtTime(0, now + 0.5);
                this.cleanupTimer = setTimeout(() => {
                    this.cleanup();
                    this.cleanupTimer = null;
                }, 550);
            } else {
                this.gainNode.gain.value = 0;
                this.cleanup();
            }
            this.currentMode = null;
        }

        cleanup() {
            this.activeNodes.forEach(node => {
                try {
                    if (node.stop) node.stop();
                    node.disconnect();
                } catch(e) {}
            });
            this.activeNodes = [];
        }

        startVisuals(hz) {
            // Visual entrainment using opacity pulses matching Hz
            // Note: CSS transitions might be too slow for >10Hz, so we use requestAnimationFrame or fast intervals
            // For stability, we'll use a CSS animation injection or simple JS toggle

            const periodMs = 1000 / hz;

            // Limit visual strobe for safety (cap at 15Hz for visuals, even if audio is 40Hz)
            // Gamma (40Hz) visual strobe is annoying/dangerous. We'll use a sub-harmonic.
            let visualHz = hz;
            while (visualHz > 12) visualHz /= 2;

            const visualPeriodMs = 1000 / visualHz;
            let isOn = false;

            this.pulseInterval = setInterval(() => {
                isOn = !isOn;
                this.visualOverlay.style.opacity = isOn ? '0.15' : '0';
            }, visualPeriodMs / 2);
        }
    }

    // --- SOUND ENGINE ---
    class SoundEngine {
        constructor() {
            this.ctx = null;
            this.masterGain = null;
            this.spatialPanner = null;
            this.filterNode = null;
            this.entrainment = null; // New Module
            this.isMuted = true;
            this.currentNodes = [];
            this.activeTheme = 'dawn';
            this.noiseBuffer = null;
            this.isFocusMode = false;
        }

        init() {
            if (this.ctx) return;
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            this.ctx = new AudioContext();

            // Master chain: Filter -> Panner -> MasterGain -> Destination
            this.masterGain = this.ctx.createGain();
            this.masterGain.gain.value = 0;

            this.spatialPanner = this.ctx.createStereoPanner();
            this.spatialPanner.pan.value = 0;

            this.filterNode = this.ctx.createBiquadFilter();
            this.filterNode.type = 'lowpass';
            this.filterNode.frequency.value = 5000; // Initial soft cutoff

            this.filterNode.connect(this.spatialPanner);
            this.spatialPanner.connect(this.masterGain);
            this.masterGain.connect(this.ctx.destination);

            // Init Entrainment (Connects directly to destination to bypass spatial/filter effects of the environment)
            this.entrainment = new EntrainmentEngine(this.ctx, this.ctx.destination);

            // Generate White/Pink Noise Buffer for reuse
            this.createNoiseBuffer();
        }

        createNoiseBuffer() {
            const bufferSize = 2 * this.ctx.sampleRate;
            this.noiseBuffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
            const output = this.noiseBuffer.getChannelData(0);
            let lastOut = 0;
            for (let i = 0; i < bufferSize; i++) {
                // Pink noise approximation
                const white = Math.random() * 2 - 1;
                output[i] = (lastOut + (0.02 * white)) / 1.02;
                lastOut = output[i];
                output[i] *= 3.5;
            }
        }

        async toggle() {
            this.init();
            if (this.ctx.state === 'suspended') await this.ctx.resume();

            if (this.isMuted) {
                this.play();
            } else {
                this.stop();
            }
            return !this.isMuted;
        }

        play() {
            this.isMuted = false;
            const now = this.ctx.currentTime;
            this.masterGain.gain.cancelScheduledValues(now);
            this.masterGain.gain.setValueAtTime(this.masterGain.gain.value, now);
            this.masterGain.gain.linearRampToValueAtTime(0.3, now + 2); // Fade in

            this.playTheme(this.activeTheme);
        }

        stop() {
            this.isMuted = true;
            const now = this.ctx.currentTime;
            this.masterGain.gain.cancelScheduledValues(now);
            this.masterGain.gain.setValueAtTime(this.masterGain.gain.value, now);
            this.masterGain.gain.linearRampToValueAtTime(0, now + 1); // Fade out

            // Stop entrainment too
            if (this.entrainment) this.entrainment.stop(true);

            // Cleanup nodes after fade
            setTimeout(() => this.stopAllNodes(), 1100);
        }

        stopAllNodes() {
            this.currentNodes.forEach(item => {
                try {
                    if (item.stop) item.stop();
                    item.disconnect();
                } catch(e) {}
            });
            this.currentNodes = [];
        }

        setTheme(theme) {
            if (this.activeTheme === theme) return;
            this.activeTheme = theme;
            if (!this.isMuted) {
                // Crossfade-like restart
                this.stopAllNodes();
                this.playTheme(theme);
            }
        }

        setFocusMode(isActive) {
            this.isFocusMode = isActive;
            if (!this.ctx || this.isMuted) return;

            const now = this.ctx.currentTime;

            if (!isActive) {
                // Reset filter and volume when exiting focus mode
                this.filterNode.frequency.cancelScheduledValues(now);
                this.filterNode.frequency.setTargetAtTime(5000, now, 1);

                this.masterGain.gain.cancelScheduledValues(now);
                this.masterGain.gain.setTargetAtTime(0.3, now, 1);
            }
        }

        breathingStep(index) {
            if (!this.isFocusMode || !this.ctx || this.isMuted) return;
            const now = this.ctx.currentTime;
            const duration = 4;

            // Modulate Filter and Volume for breathing
            // 0: Inhale, 1: Hold (Full), 2: Exhale, 3: Hold (Empty)

            this.filterNode.frequency.cancelScheduledValues(now);
            this.masterGain.gain.cancelScheduledValues(now);

            if (index === 0) { // Inhale
                // Filter opens up, Volume swells slightly
                this.filterNode.frequency.exponentialRampToValueAtTime(8000, now + duration);
                this.masterGain.gain.linearRampToValueAtTime(0.5, now + duration);
            } else if (index === 1) { // Hold Full
                this.filterNode.frequency.setTargetAtTime(8000, now, 0.1);
                this.masterGain.gain.setTargetAtTime(0.5, now, 0.1);
            } else if (index === 2) { // Exhale
                // Filter closes, Volume dips
                this.filterNode.frequency.exponentialRampToValueAtTime(400, now + duration);
                this.masterGain.gain.linearRampToValueAtTime(0.2, now + duration);
            } else if (index === 3) { // Hold Empty
                this.filterNode.frequency.setTargetAtTime(400, now, 0.1);
                this.masterGain.gain.setTargetAtTime(0.2, now, 0.1);
            }
        }

        updateSpatial(x, y) {
            // x, y are -0.5 to 0.5
            if (!this.ctx || this.isMuted || this.isFocusMode) return;

            // Pan: Map x to -0.8 to 0.8 (slightly narrower than full hard pan)
            const panVal = x * 1.6;
            this.spatialPanner.pan.setTargetAtTime(panVal, this.ctx.currentTime, 0.1);

            // Filter: Map y (height) to cutoff frequency
            // y is -0.5 (top) to 0.5 (bottom).
            // We want top = clearer (higher cutoff), bottom = muffled (lower cutoff)
            // -0.5 -> 6000Hz, 0.5 -> 500Hz
            const cutoff = 6000 - ((y + 0.5) * 5500);
            this.filterNode.frequency.setTargetAtTime(cutoff, this.ctx.currentTime, 0.1);
        }

        playTheme(theme) {
            if (this.isMuted) return;
            const now = this.ctx.currentTime;

            if (theme === 'dawn') this.playDawn(now);
            else if (theme === 'dusk') this.playDusk(now);
            else if (theme === 'meadow') this.playMeadow(now);
        }

        playDawn(now) {
            // Ethereal Pads (Sine/Tri)
            const osc1 = this.ctx.createOscillator();
            const osc2 = this.ctx.createOscillator();
            const gain = this.ctx.createGain();

            osc1.type = 'sine';
            osc1.frequency.value = 196.00; // G3
            osc2.type = 'sine';
            osc2.frequency.value = 246.94; // B3

            // Subtle detune for warmth
            osc1.detune.value = -4;
            osc2.detune.value = 4;

            gain.gain.value = 0.2;

            osc1.connect(gain);
            osc2.connect(gain);
            gain.connect(this.filterNode);

            osc1.start(now);
            osc2.start(now);

            this.currentNodes.push(osc1, osc2, gain);
        }

        playDusk(now) {
            // Deep Drones
            const osc1 = this.ctx.createOscillator();
            osc1.type = 'sawtooth';
            osc1.frequency.value = 65.41; // C2

            const lpf = this.ctx.createBiquadFilter();
            lpf.type = 'lowpass';
            lpf.frequency.value = 200;

            const gain = this.ctx.createGain();
            gain.gain.value = 0.15;

            osc1.connect(lpf);
            lpf.connect(gain);
            gain.connect(this.filterNode);

            osc1.start(now);
            this.currentNodes.push(osc1, lpf, gain);
        }

        playMeadow(now) {
            // Wind noise
            const noiseSrc = this.ctx.createBufferSource();
            noiseSrc.buffer = this.noiseBuffer;
            noiseSrc.loop = true;

            const noiseFilter = this.ctx.createBiquadFilter();
            noiseFilter.type = 'bandpass';
            noiseFilter.frequency.value = 400;
            noiseFilter.Q.value = 1;

            // LFO for wind modulation
            const lfo = this.ctx.createOscillator();
            lfo.frequency.value = 0.2;
            const lfoGain = this.ctx.createGain();
            lfoGain.gain.value = 300; // Modulate frequency by +/- 300Hz

            lfo.connect(lfoGain);
            lfoGain.connect(noiseFilter.frequency);

            const gain = this.ctx.createGain();
            gain.gain.value = 0.08;

            noiseSrc.connect(noiseFilter);
            noiseFilter.connect(gain);
            gain.connect(this.filterNode);

            noiseSrc.start(now);
            lfo.start(now);

            this.currentNodes.push(noiseSrc, noiseFilter, gain, lfo, lfoGain);
        }
    }

    document.addEventListener('DOMContentLoaded', () => {
        // Get references to key DOM elements
        const body = document.body;
        const themeBloom = document.getElementById('theme-bloom');
        const parallaxLayers = document.querySelectorAll('.parallax-layer');
        const lightRays = document.getElementById('light-rays');
        const motesContainer = document.getElementById('dust-motes');
        const themeButtons = document.querySelectorAll('.controls .control-btn[id^="theme-"]');
        const togglePatternButton = document.getElementById('toggle-pattern');
        const toggleRaysButton = document.getElementById('toggle-rays');
        const focusToggleButton = document.getElementById('toggle-focus');
        const toggleSoundButton = document.getElementById('toggle-sound');
        const iconSoundOff = document.getElementById('icon-sound-off');
        const iconSoundOn = document.getElementById('icon-sound-on');
        const focusPromptEl = document.getElementById('focus-prompt');

        // Entrainment UI
        const entrainmentMenu = document.getElementById('entrainment-menu');
        const toggleBrainButton = document.getElementById('toggle-brain');
        const entrainmentOptions = document.querySelectorAll('.entrainment-option');

        const ENTRAINMENT_MODES = {
            gamma: { name: 'Hyperfocus', rate: 40, carrier: 440 }, // Gold
            beta: { name: 'Alert', rate: 20, carrier: 330 }, // Blue
            alpha: { name: 'Flow', rate: 10, carrier: 220 }, // Green
            theta: { name: 'Dream', rate: 5, carrier: 147 }  // Purple
        };

        // Initialize Sound Engine
        const soundEngine = new SoundEngine();

        // Store original prompt text for focus mode
        const originalPromptText = focusPromptEl.textContent;
        const breathPrompts = ["Breathe In", "Hold", "Breathe Out", "Hold"];
        let breathIndex = 0; // Current index for breath prompts

        let animationFrameId = null; // For parallax animation frame
        let isFocusModeActive = false; // State for focus mode
        let focusInterval = null; // Interval for breathing prompts

        /**
         * Updates the active state of control buttons based on the current theme or pattern.
         */
        function updateControlActiveStates() {
            // Update active theme button
            const currentTheme = body.dataset.theme;
            themeButtons.forEach(button => {
                if (button.id === `theme-${currentTheme}`) {
                    button.classList.add('active');
                } else {
                    button.classList.remove('active');
                }
            });

            // Update Sound Button State
            if (!soundEngine.isMuted) {
                toggleSoundButton.classList.add('active');
                toggleSoundButton.setAttribute('aria-label', 'Sound Off');
                iconSoundOff.style.display = 'none';
                iconSoundOn.style.display = 'block';
            } else {
                toggleSoundButton.classList.remove('active');
                toggleSoundButton.setAttribute('aria-label', 'Sound On');
                iconSoundOff.style.display = 'block';
                iconSoundOn.style.display = 'none';
            }

            // Update active state of pattern toggle button
            if (body.classList.contains('pattern-active')) {
                togglePatternButton.classList.add('active');
            } else {
                togglePatternButton.classList.remove('active');
            }

            // Update active state of light rays toggle button
            if (body.classList.contains('light-rays-active')) {
                toggleRaysButton.classList.add('active');
            } else {
                toggleRaysButton.classList.remove('active');
            }

            // Update Brainwave Button
            if (soundEngine.entrainment && soundEngine.entrainment.currentMode) {
                toggleBrainButton.classList.add('active');
            } else {
                toggleBrainButton.classList.remove('active');
            }

            // Sync Entrainment Menu Options
            entrainmentOptions.forEach(opt => {
                if (soundEngine.entrainment && soundEngine.entrainment.currentMode === ENTRAINMENT_MODES[opt.dataset.mode]) {
                    opt.classList.add('active');
                } else {
                    opt.classList.remove('active');
                }
            });

            // Update focus toggle button state (handled by toggleFocusMode itself)
        }

        /* --- PARALLAX & TILT EFFECT --- */
        let targetX = 0;
        let targetY = 0;
        let currentX = 0;
        let currentY = 0;

        // Tilt variables
        const controlsEl = document.querySelector('.controls');
        let tiltX = 0;
        let tiltY = 0;
        let currentTiltX = 0;
        let currentTiltY = 0;

        /**
         * Handles mouse and touch movements to update target coordinates.
         * @param {Object} coords - Object containing clientX and clientY coordinates.
         */
        function handleParallaxMove(coords) {
            // Disable parallax input if focus mode is active
            if (isFocusModeActive) return; 

            const { clientX, clientY } = coords;
            const windowWidth = window.innerWidth;
            const windowHeight = window.innerHeight;

            // Calculate normalized coordinates (-0.5 to 0.5) for parallax
            targetX = (clientX / windowWidth) - 0.5;
            targetY = (clientY / windowHeight) - 0.5;

            // Calculate tilt based on mouse position relative to controls
            // We want the controls to tilt towards the mouse
            const controlsRect = controlsEl.getBoundingClientRect();
            const controlsCenterX = controlsRect.left + controlsRect.width / 2;
            const controlsCenterY = controlsRect.top + controlsRect.height / 2;
            
            // Max tilt angle in degrees
            const maxTilt = 8;

            // Calculate distance normalized (-1 to 1)
            const deltaX = (clientX - controlsCenterX) / (windowWidth / 2);
            const deltaY = (clientY - controlsCenterY) / (windowHeight / 2);

            // Invert Y because positive Y is down
            tiltX = deltaY * maxTilt;
            tiltY = -deltaX * maxTilt;

            // Update CSS var for light rays
            const mouseXPercent = (clientX / windowWidth) * 100;
            lightRays.style.setProperty('--mouse-x', `${mouseXPercent}%`);
        }

        // Linear interpolation function for smooth movement
        function lerp(start, end, factor) {
            return start + (end - start) * factor;
        }

        function animateParallax() {
            if (!isFocusModeActive) {
                // Smoothly interpolate current towards target
                // 0.035 is smoother than 0.05
                currentX = lerp(currentX, targetX, 0.035);
                currentY = lerp(currentY, targetY, 0.035);

                // Interpolate tilt
                currentTiltX = lerp(currentTiltX, tiltX, 0.05);
                currentTiltY = lerp(currentTiltY, tiltY, 0.05);

                const multipliers = { 
                    'background-canvas': 40, // Increased depth
                    'main': -15,
                    // 'controls': -6 // Controls are handled separately now
                };

                parallaxLayers.forEach(layer => {
                    // Skip controls in the generic loop to handle it specially
                    if (layer.classList.contains('controls')) return;

                    const multiplier = multipliers[layer.id] || multipliers[layer.className.split(' ')[0]];
                    if (layer && layer.style && multiplier) {
                        layer.style.transform = `translate3d(${currentX * multiplier}px, ${currentY * multiplier}px, 0)`;
                    }
                });

                // Update Spatial Audio
                soundEngine.updateSpatial(currentX, currentY);

                // Apply specific transform to controls (parallax position + 3D tilt)
                // Note: We need to maintain the centering translateX(-50%)
                const controlsParallaxX = currentX * -8;
                const controlsParallaxY = currentY * -8;

                // Only apply tilt on larger screens (desktop) where mouse is primary
                if (window.innerWidth > 768) {
                    controlsEl.style.transform = `
                        perspective(1000px)
                        translateX(calc(-50% + ${controlsParallaxX}px))
                        translateY(${controlsParallaxY}px)
                        rotateX(${currentTiltX}deg)
                        rotateY(${currentTiltY}deg)
                    `;
                } else {
                    // Mobile: just parallax, no tilt, keep flat
                    controlsEl.style.transform = `
                        translateX(calc(-50% + ${controlsParallaxX}px))
                        translateY(${controlsParallaxY}px)
                    `;
                }
            }
            requestAnimationFrame(animateParallax);
        }

        // Start the animation loop
        requestAnimationFrame(animateParallax);

        // Event listeners for parallax
        window.addEventListener('mousemove', handleParallaxMove);
        window.addEventListener('touchmove', (e) => {
            // Check if there are touches to prevent errors
            if (e.touches.length > 0) {
                handleParallaxMove(e.touches[0]);
            }
        }, { passive: true }); // Use passive listener for better scroll performance

        // --- THEME BLOOM EFFECT ---
        /**
         * Triggers a visual "bloom" effect when switching themes.
         * @param {string} newTheme - The ID of the new theme to switch to.
         * @param {MouseEvent} event - The click event that triggered the theme change.
         */
        function triggerThemeBloom(newTheme, event) {
            // Set the bloom element's position to the click coordinates
            themeBloom.style.left = `${event.clientX}px`;
            themeBloom.style.top = `${event.clientY}px`;

            // Reset bloom scale and remove blooming class to re-trigger animation
            themeBloom.classList.remove('is-blooming');
            themeBloom.style.transform = 'scale(0)'; // Ensure it starts from 0

            // Force reflow to restart animation
            void themeBloom.offsetWidth; 

            // Add blooming class to start the animation
            themeBloom.classList.add('is-blooming');

            // After the bloom animation starts, change the theme
            // Delay theme change slightly to let bloom cover the screen
            setTimeout(() => {
                body.dataset.theme = newTheme;
                updateControlActiveStates(); // Update active state after theme change
            }, varCssToMs('--timing-fast')); // Match with the fast timing for a quick transition

            // Remove blooming class after animation completes to reset for next bloom
            themeBloom.addEventListener('transitionend', () => {
                themeBloom.classList.remove('is-blooming');
                themeBloom.style.transform = 'scale(0)'; // Reset size
            }, { once: true }); // Ensure this listener runs only once
        }

        /**
         * Helper function to convert CSS variable timing to milliseconds.
         * @param {string} varName - The name of the CSS variable (e.g., '--timing-fast').
         * @returns {number} The time in milliseconds.
         */
        function varCssToMs(varName) {
            const value = getComputedStyle(document.documentElement).getPropertyValue(varName);
            return parseFloat(value) || 0; // Return 0 if parsing fails
        }

        // Event listeners for theme buttons
        themeButtons.forEach(button => {
            button.addEventListener('click', (event) => {
                const newTheme = button.id.replace('theme-', '');
                triggerThemeBloom(newTheme, event);

                // Update audio theme
                soundEngine.setTheme(newTheme);
            });
        });

        // Sound Toggle Listener
        toggleSoundButton.addEventListener('click', async () => {
            await soundEngine.toggle();
            updateControlActiveStates();
        });

        // --- PATTERN TOGGLE ---
        /**
         * Toggles the geometric pattern visibility.
         */
        function toggleGeometricPattern() {
            body.classList.toggle('pattern-active');
            updateControlActiveStates(); // Update active state of button
        }

        // Event listener for pattern toggle button
        togglePatternButton.addEventListener('click', toggleGeometricPattern);

        // --- LIGHT RAYS TOGGLE ---
        /**
         * Toggles the light rays visibility.
         */
        function toggleLightRays() {
            body.classList.toggle('light-rays-active');
            updateControlActiveStates();
        }

        // Event listener for light rays toggle button
        toggleRaysButton.addEventListener('click', toggleLightRays);

        // --- ENTRAINMENT UI LOGIC ---
        toggleBrainButton.addEventListener('click', (e) => {
            e.stopPropagation();
            entrainmentMenu.classList.toggle('active');
        });

        // Close menu when clicking outside
        document.addEventListener('click', (e) => {
            if (!entrainmentMenu.contains(e.target) && !toggleBrainButton.contains(e.target)) {
                entrainmentMenu.classList.remove('active');
            }
        });

        entrainmentOptions.forEach(opt => {
            opt.addEventListener('click', () => {
                const modeKey = opt.dataset.mode;
                const modeData = ENTRAINMENT_MODES[modeKey];

                // Ensure engine is initialized
                if (!soundEngine.ctx) soundEngine.init();

                // If clicking active, toggle off
                if (opt.classList.contains('active')) {
                    opt.classList.remove('active');
                    soundEngine.entrainment.stop(true);
                } else {
                    // Activate new mode
                    entrainmentOptions.forEach(o => o.classList.remove('active'));
                    opt.classList.add('active');

                    // Resume audio context if needed
                    if (soundEngine.ctx.state === 'suspended') soundEngine.ctx.resume();

                    soundEngine.entrainment.setMode(modeData);
                }
                updateControlActiveStates();
            });
        });

        // --- DUST MOTES GENERATION ---
        const numMotes = 30; // Number of dust motes to generate
        for (let i = 0; i < numMotes; i++) {
            const mote = document.createElement('div');
            mote.className = 'mote';
            const size = Math.random() * 3 + 1; // Random size between 1px and 4px
            mote.style.width = `${size}px`; 
            mote.style.height = `${size}px`;
            mote.style.left = `${Math.random() * 100}%`; // Random horizontal position
            mote.style.top = `${Math.random() * 100}%`; // Random vertical position
            mote.style.animationDuration = `${Math.random() * 20 + 15}s`; // Random animation duration
            mote.style.animationDelay = `${Math.random() * 10}s`; // Random animation delay
            // Custom CSS properties for animation keyframes
            mote.style.setProperty('--x-end', Math.random() * 200 - 100); 
            mote.style.setProperty('--y-end', Math.random() * 200 - 100);
            motesContainer.appendChild(mote);
        }

        // --- BREATHING FOCUS MODE LOGIC ---
        /**
         * Toggles the breathing focus mode on and off.
         */
        function toggleFocusMode() {
            isFocusModeActive = !isFocusModeActive;
            body.classList.toggle('focus-mode-active', isFocusModeActive);
            focusToggleButton.classList.toggle('active', isFocusModeActive);

            // Sync Sound Engine
            soundEngine.setFocusMode(isFocusModeActive);

            if (isFocusModeActive) {
                // --- Activate Focus Mode ---
                breathIndex = 0; // Reset breath prompt index
                
                /**
                 * Updates the breathing prompt text and controls mote animation.
                 */
                const updatePrompt = () => {
                    // Sync Audio with Breath Step
                    soundEngine.breathingStep(breathIndex);

                    focusPromptEl.style.opacity = '0'; // Fade out current prompt
                    setTimeout(() => {
                        const currentPrompt = breathPrompts[breathIndex];
                        focusPromptEl.textContent = currentPrompt; // Set new prompt
                        focusPromptEl.style.opacity = '1'; // Fade in new prompt

                        // Pause motes during "Hold" phases
                        motesContainer.classList.toggle('is-holding', currentPrompt === "Hold");

                        // Move to the next prompt
                        breathIndex = (breathIndex + 1) % breathPrompts.length;
                    }, 500); // Wait for fade out transition (matching CSS)
                };
                
                updatePrompt(); // Initial call to display first prompt
                focusInterval = setInterval(updatePrompt, 4000); // Cycle prompts every 4 seconds
            } else {
                // --- Deactivate Focus Mode ---
                if (focusInterval) {
                    clearInterval(focusInterval); // Stop the breathing prompt interval
                }
                focusInterval = null;
                motesContainer.classList.remove('is-holding'); // Resume mote animation
                focusPromptEl.style.opacity = '0'; // Fade out current prompt
                setTimeout(() => {
                    focusPromptEl.textContent = originalPromptText; // Restore original prompt
                    focusPromptEl.style.opacity = '1'; // Fade in original prompt
                }, 500); // Wait for fade out transition
            }
        }
        
        // Event listener for focus mode toggle button
        focusToggleButton.addEventListener('click', toggleFocusMode);

        // Allow clicking anywhere on the background to exit focus mode
        document.getElementById('background-canvas').addEventListener('click', () => {
            if (isFocusModeActive) {
                toggleFocusMode();
            }
        });

        // Initial setup: Set active state for the current theme on load
        updateControlActiveStates();
    });
    </script>
</body>
</html>

