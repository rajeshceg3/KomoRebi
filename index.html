<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Komorebi</title>
    
    <!-- Google Fonts - Inter for a clean, modern look -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;500;700&display=swap" rel="stylesheet">
    
    <style>
        /* CSS Variables for Theming and Animation */
        :root {
            /* Typography Scale */
            --font-display: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            --font-size-h1: clamp(3rem, 8vw, 6rem);
            --font-size-p: clamp(1rem, 1.5vw, 1.25rem);

            /* Default Dawn Theme Palette - Refined for Warmth */
            --color-bg-1: #FDF6F3;
            --color-bg-2: #F4E4DC;
            --color-shape-1: #E8D3C8;
            --color-shape-2: #DCA995;
            --color-text-primary: #4A3B32;
            --color-text-secondary: #8D7B72;
            --color-shadow: rgba(74, 59, 50, 0.08);
            --color-bloom: #DCA995;
            --color-dock-bg: rgba(253, 246, 243, 0.65);
            --color-dock-border: rgba(255, 255, 255, 0.4);

            /* Animation Timings */
            --timing-fast: 250ms;
            --timing-med: 500ms;
            --timing-slow: 1000ms;

            /* Animation Easing Functions - "Ultrathink" Smoothness */
            --easing-standard: cubic-bezier(0.2, 0.0, 0.2, 1.0); /* High-quality standard easing */
            --easing-spring: cubic-bezier(0.175, 0.885, 0.32, 1.275); /* Bouncy spring */
            --easing-smooth: cubic-bezier(0.4, 0.0, 0.2, 1);
        }

        /* Base Styles */
        * { 
            box-sizing: border-box;
            margin: 0; 
            padding: 0; 
            -webkit-font-smoothing: antialiased; /* Crisp text on Mac */
            -moz-osx-font-smoothing: grayscale;
        }
        html, body { 
            height: 100%;
            height: 100dvh; /* Dynamic Viewport Height for mobile */
            overflow: hidden;
            font-family: var(--font-display);
            background-color: var(--color-bg-1);
        }
        body { 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            transition: background-color var(--timing-slow) var(--easing-standard);
        }

        /* Noise Overlay for Texture */
        #noise-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 90;
            pointer-events: none;
            opacity: 0.035;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.65' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)' opacity='1'/%3E%3C/svg%3E");
        }

        /* Parallax Layers */
        .parallax-layer { 
            position: fixed;
            will-change: transform;
            /* Removed linear transition for direct JS control (smoother) */
            /* transform-style: preserve-3d; */
        }

        /* Background Canvas Layer (for subtle gradients and drift) */
        #background-canvas { 
            top: -50%; 
            left: -50%; 
            width: 200%; 
            height: 200%; /* Larger than viewport to allow for drift and parallax */
            z-index: 1; 
            background: 
                radial-gradient(circle at 70% 30%, var(--color-bg-2), transparent 40%), 
                radial-gradient(circle at 30% 70%, var(--color-shape-1), transparent 40%), 
                radial-gradient(circle at 50% 50%, var(--color-bg-1), transparent 30%); /* Multiple radial gradients for depth */
            background-size: 100% 100%; 
            animation: slowDrift 45s linear infinite alternate; /* Continuous slow movement */
        }
        @keyframes slowDrift { 
            from { transform: translate(0, 0); } 
            to { transform: translate(2%, 1%); } /* Subtle drift effect */
        }
        
        /* Dust Motes Layer */
        #dust-motes { 
            position: fixed; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%; 
            z-index: 2; 
            pointer-events: none;
        }
        .mote { 
            position: absolute; 
            background-color: var(--color-shape-1); 
            border-radius: 50%; 
            opacity: 0.6;
            filter: blur(1px);
            animation: float 25s infinite linear;
            will-change: transform, opacity; 
            transition: background-color var(--timing-slow) var(--easing-standard);
            box-shadow: 0 0 4px var(--color-shape-1); /* Glow effect */
        }
        @keyframes float { 
            0% { transform: translateX(0) translateY(0); opacity: 0.5; } 
            50% { transform: translateX(calc(var(--x-end) * 1px)) translateY(calc(var(--y-end) * 1px)); opacity: 0.8; } /* Move and become slightly more opaque */
            100% { transform: translateX(0) translateY(0); opacity: 0.5; } 
        }
        
        /* Geometric Pattern Layer */
        #geometric-pattern { 
            position: fixed; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%; 
            z-index: 3; 
            opacity: 0; /* Initially hidden */
            transition: opacity var(--timing-slow) var(--easing-standard); /* Smooth fade in/out */
            pointer-events: none; 
        }
        body.pattern-active #geometric-pattern { 
            opacity: 0.15; /* Visible when active */
        }
        #geometric-pattern svg { 
            width: 100%; 
            height: 100%; 
            stroke: var(--color-text-secondary); /* Pattern lines color */
        }
        
        /* Main Content Area */
        main { 
            position: relative; 
            z-index: 10; 
            text-align: center; 
            color: var(--color-text-primary); 
            animation: fadeIn 2s var(--easing-standard) forwards; /* Fade in on load */
            opacity: 0; 
            transition: color var(--timing-slow) var(--easing-standard), transform 100ms linear; /* Smooth color and parallax transition */
        }
        @keyframes fadeIn { 
            to { opacity: 1; } 
        }
        h1 { 
            font-size: var(--font-size-h1);
            font-weight: 500; 
            letter-spacing: -0.02em; /* Tighter tracking for modern look */
            line-height: 1.1;
            text-transform: none; /* Removed uppercase for a more relaxed feel */
            transition: transform var(--timing-slow) var(--easing-standard);
        }
        p { 
            font-size: var(--font-size-p);
            font-weight: 400;
            letter-spacing: 0.01em;
            margin-top: 1.5vh;
            color: var(--color-text-secondary); 
            transition: color var(--timing-slow) var(--easing-standard); 
        }
        #focus-prompt { 
            display: inline-block; 
            transition: opacity var(--timing-med) var(--easing-standard); /* Smooth fade for focus prompt text */
        }

        /* Control Dock */
        .controls { 
            position: fixed; 
            bottom: 3rem;
            left: 50%; 
            z-index: 20; 
            display: flex; 
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            border-radius: 24px;
            background: var(--color-dock-bg);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid var(--color-dock-border);
            box-shadow:
                0 4px 6px -1px rgba(0, 0, 0, 0.05),
                0 10px 15px -3px rgba(0, 0, 0, 0.05),
                0 0 0 1px rgba(255, 255, 255, 0.1) inset;
            animation: fadeInUp 1.2s cubic-bezier(0.2, 0.8, 0.2, 1) forwards;
            opacity: 0; 
            transform: translateX(-50%) translateY(20px);
            transition: transform 100ms linear, opacity 0.5s ease;
        }

        @keyframes fadeInUp {
            to { opacity: 1; transform: translateX(-50%) translateY(0); }
        }

        .control-group {
            display: flex;
            gap: 4px;
            padding: 0 4px;
            border-right: 1px solid var(--color-dock-border);
        }
        .control-group:last-child {
            border-right: none;
        }

        .control-btn {
            position: relative;
            width: 44px;
            height: 44px;
            cursor: pointer; 
            border-radius: 12px;
            background: transparent;
            display: flex; 
            justify-content: center; 
            align-items: center; 
            color: var(--color-text-secondary);
            transition: all var(--timing-fast) var(--easing-standard);
        }

        .control-btn:hover {
            background-color: rgba(255, 255, 255, 0.2);
            color: var(--color-text-primary);
            transform: translateY(-2px);
        }

        .control-btn.active {
            background-color: var(--color-shape-2);
            color: var(--color-bg-1);
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }
        .control-btn:active {
            transform: scale(0.95);
        }

        .control-btn svg {
            width: 20px;
            height: 20px;
            stroke: currentColor;
            stroke-width: 2;
            fill: none; 
            stroke-linecap: round; 
            stroke-linejoin: round; 
            transition: all 0.2s ease;
        }

        /* Tooltips */
        .control-btn::after {
            content: attr(aria-label);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%) translateY(-8px) scale(0.95);
            padding: 6px 10px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            font-size: 12px;
            border-radius: 6px;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: all 0.2s cubic-bezier(0.2, 0.8, 0.2, 1);
            z-index: 100;
            margin-bottom: 8px;
            font-weight: 500;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }

        .control-btn:hover::after {
            opacity: 1;
            transform: translateX(-50%) translateY(0) scale(1);
        }

        /* Theme Bloom Effect */
        #theme-bloom { 
            position: fixed; 
            z-index: 99; 
            top: 50%; 
            left: 50%; 
            width: 1px; 
            height: 1px; 
            background: var(--color-bloom); 
            border-radius: 50%; 
            transform: scale(0); /* Initially invisible */
            pointer-events: none; 
        }
        #theme-bloom.is-blooming { 
            transition: transform 1s var(--easing-bloom), background-color var(--timing-med) var(--easing-standard); /* Bloom animation */
            transform: scale(3000); /* Expand to cover screen */
        }
        
        /* Theming - Dynamic CSS Variable Updates */
        body[data-theme="dawn"] { 
            --color-bg-1: #FDF6F3; --color-bg-2: #F4E4DC; --color-shape-1: #E8D3C8; --color-shape-2: #DCA995; --color-text-primary: #4A3B32; --color-text-secondary: #8D7B72; --color-shadow: rgba(74, 59, 50, 0.08); --color-bloom: #DCA995; --color-light-ray: rgba(255, 220, 180, 0.3); --color-dock-bg: rgba(253, 246, 243, 0.65); --color-dock-border: rgba(255, 255, 255, 0.5);
        }
        body[data-theme="dusk"] { 
            --color-bg-1: #1E202C; --color-bg-2: #15161E; --color-shape-1: #383B53; --color-shape-2: #7A81A8; --color-text-primary: #F0F2F5; --color-text-secondary: #A0A4B8; --color-shadow: rgba(0, 0, 0, 0.3); --color-bloom: #7A81A8; --color-light-ray: rgba(173, 216, 250, 0.12); --color-dock-bg: rgba(30, 32, 44, 0.6); --color-dock-border: rgba(255, 255, 255, 0.1);
        }
        body[data-theme="meadow"] { 
            --color-bg-1: #F1F8F4; --color-bg-2: #E1EFE6; --color-shape-1: #C5E1D0; --color-shape-2: #88BBA0; --color-text-primary: #2C4A34; --color-text-secondary: #6B8E76; --color-shadow: rgba(44, 74, 52, 0.08); --color-bloom: #88BBA0; --color-light-ray: rgba(220, 255, 220, 0.25); --color-dock-bg: rgba(241, 248, 244, 0.65); --color-dock-border: rgba(255, 255, 255, 0.4);
        }

        /* --- LIGHT RAYS --- */
        #light-rays {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 4;
            pointer-events: none;
            opacity: 0;
            --ray-color: var(--color-light-ray, rgba(255, 220, 180, 0.25));
            /* Enhanced gradient structure for more realistic "God Rays" */
            background:
                conic-gradient(from 180deg at 50% -10%, transparent 40%, var(--ray-color) 50%, transparent 60%),
                radial-gradient(circle at 50% 0%, var(--ray-color) 0%, transparent 60%);
            background-size: 200% 200%;
            filter: blur(40px); /* Increased blur for softness */
            mix-blend-mode: screen; /* Or overlay/soft-light depending on bg */
            transition: opacity var(--timing-slow) var(--easing-standard);
            animation: rayShimmer 20s ease-in-out infinite alternate;
        }

        body.light-rays-active #light-rays {
            opacity: 1;
        }

        @keyframes rayShimmer {
            0% { transform: translateX(-5%) scale(1.1); opacity: 0.8; }
            50% { opacity: 1; }
            100% { transform: translateX(5%) scale(1.2); opacity: 0.8; }
        }
        /* --- END LIGHT RAYS --- */

        /* --- BREATHING FOCUS MODE STYLES --- */
        @keyframes pulse {
            0% { transform: scale(1); }
            25% { transform: scale(1.03); } /* Inhale complete */
            50% { transform: scale(1.03); } /* Hold complete */
            75% { transform: scale(1); }    /* Exhale complete */
            100% { transform: scale(1); }   /* Hold complete */
        }

        body.focus-mode-active h1 {
            opacity: 0.5;
            transform: scale(0.95);
        }

        /* Breathing Ring Visualization */
        #breathing-ring {
            position: fixed;
            top: 50%;
            left: 50%;
            width: 300px;
            height: 300px;
            border-radius: 50%;
            border: 2px solid var(--color-shape-2);
            transform: translate(-50%, -50%) scale(0.8);
            opacity: 0;
            pointer-events: none;
            z-index: 5;
            transition: opacity 0.5s ease;
        }

        #breathing-ring::after {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            border-radius: 50%;
            background: var(--color-shape-2);
            opacity: 0.1;
        }

        body.focus-mode-active #breathing-ring {
            opacity: 1;
            animation: breatheAnimation 16s infinite ease-in-out;
        }

        @keyframes breatheAnimation {
            0% { transform: translate(-50%, -50%) scale(0.8); opacity: 0.5; } /* Start Inhale */
            25% { transform: translate(-50%, -50%) scale(1.2); opacity: 1; } /* Inhale Complete */
            50% { transform: translate(-50%, -50%) scale(1.2); opacity: 1; } /* Hold */
            75% { transform: translate(-50%, -50%) scale(0.8); opacity: 0.5; } /* Exhale Complete */
            100% { transform: translate(-50%, -50%) scale(0.8); opacity: 0.5; } /* Hold */
        }

        body.focus-mode-active .controls {
            border-color: transparent;
            background: transparent;
            box-shadow: none;
            backdrop-filter: none;
        }

        body.focus-mode-active .controls .control-group {
            border-right: none;
        }

        body.focus-mode-active .controls .control-btn {
            opacity: 0;
            pointer-events: none;
            transform: translateY(20px);
        }

        body.focus-mode-active .controls #toggle-focus.active {
            opacity: 0.8;
            pointer-events: auto;
            transform: translateY(0);
        }
        
        #dust-motes.is-holding .mote {
            transition: all 1s ease;
            opacity: 0.2;
        }
        /* --- END FOCUS MODE STYLES --- */

        /* Responsive Adjustments for Smaller Screens */
        @media (max-width: 768px) {
            h1 { font-size: 14vw; } /* Larger font for mobile H1 */
            p { font-size: 3vw; letter-spacing: 0.3vw; } /* Larger font for mobile paragraph */
            .control-leaf { width: 50px; height: 50px; } /* Smaller control buttons */
            .control-leaf svg { width: 24px; height: 24px; } /* Smaller icons */
        }
    </style>
</head>
<body data-theme="dawn">

    <!-- Parallax Layer: Background Canvas with Gradients -->
    <div id="background-canvas" class="parallax-layer"></div>
    
    <!-- Parallax Layer: Dust Motes Container -->
    <div id="dust-motes"></div>
    
    <!-- Light Rays Layer -->
    <div id="light-rays"></div>

    <!-- Noise Overlay -->
    <div id="noise-overlay"></div>

    <!-- Geometric Pattern Layer (initially hidden) -->
    <div id="geometric-pattern">
        <svg width="100%" height="100%" xmlns="http://www.w3.org/2000/svg">
            <defs>
                <!-- Define a pattern of dots -->
                <pattern id="dot-pattern" x="0" y="0" width="20" height="20" patternUnits="userSpaceOnUse">
                    <circle cx="2" cy="2" r="1" fill="currentColor"/>
                </pattern>
            </defs>
            <!-- Apply the dot pattern to a full-size rectangle -->
            <rect width="100%" height="100%" fill="url(#dot-pattern)" />
        </svg>
    </div>

    <!-- Main Content Layer -->
    <main class="parallax-layer">
        <h1>Komorebi</h1>
        <p><span id="focus-prompt">A space for quiet thought</span></p>
    </main>

    <!-- Breathing Ring -->
    <div id="breathing-ring"></div>

    <!-- Control Buttons Layer -->
    <div class="controls parallax-layer">
        <!-- Theme Buttons Group -->
        <div class="control-group">
            <div class="control-btn" id="theme-dawn" aria-label="Dawn">
                <svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line></svg>
            </div>
            <div class="control-btn" id="theme-dusk" aria-label="Dusk">
                <svg viewBox="0 0 24 24"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg>
            </div>
            <div class="control-btn" id="theme-meadow" aria-label="Meadow">
                <svg viewBox="0 0 24 24"><path d="M20.9 10.1a9.3 9.3 0 0 0-8.8-8.8A9.3 9.3 0 0 0 3.1 10.1c0 5.1 4.2 9.3 9.3 9.3s9.3-4.2 9.3-9.3z"></path><path d="M12 2v20"></path></svg>
            </div>
        </div>
        
        <!-- Features Group -->
        <div class="control-group">
            <div class="control-btn" id="toggle-pattern" aria-label="Patterns">
                <svg viewBox="0 0 24 24"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><circle cx="8.5" cy="8.5" r="1.5"></circle><circle cx="15.5" cy="8.5" r="1.5"></circle><circle cx="15.5" cy="15.5" r="1.5"></circle><circle cx="8.5" cy="15.5" r="1.5"></circle></svg>
            </div>

            <div class="control-btn" id="toggle-rays" aria-label="Light Rays">
                <svg viewBox="0 0 24 24"><path d="M12 3v3m0 12v3M3 12h3m12 0h3m-2.828-6.172l-2.122 2.122m-8.1 8.1l-2.122 2.122m0-12.244l2.122 2.122m8.1 8.1l2.122 2.122M12 8a4 4 0 1 0 0 8 4 4 0 0 0 0-8z"></path></svg>
            </div>

            <div class="control-btn" id="toggle-focus" aria-label="Focus Mode">
                <svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"></circle><circle cx="12" cy="12" r="3"></circle></svg>
            </div>
        </div>
    </div>
    
    <!-- Theme Bloom Element (for transition effect) -->
    <div id="theme-bloom"></div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        // Get references to key DOM elements
        const body = document.body;
        const themeBloom = document.getElementById('theme-bloom');
        const parallaxLayers = document.querySelectorAll('.parallax-layer');
        const lightRays = document.getElementById('light-rays');
        const motesContainer = document.getElementById('dust-motes');
        const themeButtons = document.querySelectorAll('.controls .control-btn[id^="theme-"]');
        const togglePatternButton = document.getElementById('toggle-pattern');
        const toggleRaysButton = document.getElementById('toggle-rays');
        const focusToggleButton = document.getElementById('toggle-focus');
        const focusPromptEl = document.getElementById('focus-prompt');

        // Store original prompt text for focus mode
        const originalPromptText = focusPromptEl.textContent;
        const breathPrompts = ["Breathe In", "Hold", "Breathe Out", "Hold"];
        let breathIndex = 0; // Current index for breath prompts

        let animationFrameId = null; // For parallax animation frame
        let isFocusModeActive = false; // State for focus mode
        let focusInterval = null; // Interval for breathing prompts

        /**
         * Updates the active state of control buttons based on the current theme or pattern.
         */
        function updateControlActiveStates() {
            // Update active theme button
            const currentTheme = body.dataset.theme;
            themeButtons.forEach(button => {
                if (button.id === `theme-${currentTheme}`) {
                    button.classList.add('active');
                } else {
                    button.classList.remove('active');
                }
            });

            // Update active state of pattern toggle button
            if (body.classList.contains('pattern-active')) {
                togglePatternButton.classList.add('active');
            } else {
                togglePatternButton.classList.remove('active');
            }

            // Update active state of light rays toggle button
            if (body.classList.contains('light-rays-active')) {
                toggleRaysButton.classList.add('active');
            } else {
                toggleRaysButton.classList.remove('active');
            }

            // Update focus toggle button state (handled by toggleFocusMode itself)
        }

        /* --- PARALLAX EFFECT --- */
        let targetX = 0;
        let targetY = 0;
        let currentX = 0;
        let currentY = 0;

        /**
         * Handles mouse and touch movements to update target coordinates.
         * @param {Object} coords - Object containing clientX and clientY coordinates.
         */
        function handleParallaxMove(coords) {
            // Disable parallax input if focus mode is active
            if (isFocusModeActive) return; 

            const { clientX, clientY } = coords;
            // Calculate normalized coordinates (-0.5 to 0.5)
            targetX = (clientX / window.innerWidth) - 0.5;
            targetY = (clientY / window.innerHeight) - 0.5;
            
            // Update CSS var for light rays
            const mouseXPercent = (clientX / window.innerWidth) * 100;
            lightRays.style.setProperty('--mouse-x', `${mouseXPercent}%`);
        }

        // Linear interpolation function for smooth movement
        function lerp(start, end, factor) {
            return start + (end - start) * factor;
        }

        function animateParallax() {
            if (!isFocusModeActive) {
                // Smoothly interpolate current towards target
                // 0.05 is the "smoothness" factor - lower is smoother/slower
                currentX = lerp(currentX, targetX, 0.05);
                currentY = lerp(currentY, targetY, 0.05);

                const multipliers = { 
                    'background-canvas': 30,
                    'main': -12,
                    'controls': -6
                };

                parallaxLayers.forEach(layer => {
                    const multiplier = multipliers[layer.id] || multipliers[layer.className.split(' ')[0]];
                    if (layer && layer.style && multiplier) {
                        // Use translate3d for hardware acceleration
                        layer.style.transform = `translate3d(${currentX * multiplier}px, ${currentY * multiplier}px, 0)`;
                    }
                });
            }
            requestAnimationFrame(animateParallax);
        }

        // Start the animation loop
        requestAnimationFrame(animateParallax);

        // Event listeners for parallax
        window.addEventListener('mousemove', handleParallaxMove);
        window.addEventListener('touchmove', (e) => {
            // Check if there are touches to prevent errors
            if (e.touches.length > 0) {
                handleParallaxMove(e.touches[0]);
            }
        }, { passive: true }); // Use passive listener for better scroll performance

        // --- THEME BLOOM EFFECT ---
        /**
         * Triggers a visual "bloom" effect when switching themes.
         * @param {string} newTheme - The ID of the new theme to switch to.
         * @param {MouseEvent} event - The click event that triggered the theme change.
         */
        function triggerThemeBloom(newTheme, event) {
            // Set the bloom element's position to the click coordinates
            themeBloom.style.left = `${event.clientX}px`;
            themeBloom.style.top = `${event.clientY}px`;

            // Reset bloom scale and remove blooming class to re-trigger animation
            themeBloom.classList.remove('is-blooming');
            themeBloom.style.transform = 'scale(0)'; // Ensure it starts from 0

            // Force reflow to restart animation
            void themeBloom.offsetWidth; 

            // Add blooming class to start the animation
            themeBloom.classList.add('is-blooming');

            // After the bloom animation starts, change the theme
            // Delay theme change slightly to let bloom cover the screen
            setTimeout(() => {
                body.dataset.theme = newTheme;
                updateControlActiveStates(); // Update active state after theme change
            }, varCssToMs('--timing-fast')); // Match with the fast timing for a quick transition

            // Remove blooming class after animation completes to reset for next bloom
            themeBloom.addEventListener('transitionend', () => {
                themeBloom.classList.remove('is-blooming');
                themeBloom.style.transform = 'scale(0)'; // Reset size
            }, { once: true }); // Ensure this listener runs only once
        }

        /**
         * Helper function to convert CSS variable timing to milliseconds.
         * @param {string} varName - The name of the CSS variable (e.g., '--timing-fast').
         * @returns {number} The time in milliseconds.
         */
        function varCssToMs(varName) {
            const value = getComputedStyle(document.documentElement).getPropertyValue(varName);
            return parseFloat(value) || 0; // Return 0 if parsing fails
        }

        // Event listeners for theme buttons
        themeButtons.forEach(button => {
            button.addEventListener('click', (event) => {
                const newTheme = button.id.replace('theme-', '');
                triggerThemeBloom(newTheme, event);
            });
        });

        // --- PATTERN TOGGLE ---
        /**
         * Toggles the geometric pattern visibility.
         */
        function toggleGeometricPattern() {
            body.classList.toggle('pattern-active');
            updateControlActiveStates(); // Update active state of button
        }

        // Event listener for pattern toggle button
        togglePatternButton.addEventListener('click', toggleGeometricPattern);

        // --- LIGHT RAYS TOGGLE ---
        /**
         * Toggles the light rays visibility.
         */
        function toggleLightRays() {
            body.classList.toggle('light-rays-active');
            updateControlActiveStates();
        }

        // Event listener for light rays toggle button
        toggleRaysButton.addEventListener('click', toggleLightRays);

        // --- DUST MOTES GENERATION ---
        const numMotes = 30; // Number of dust motes to generate
        for (let i = 0; i < numMotes; i++) {
            const mote = document.createElement('div');
            mote.className = 'mote';
            const size = Math.random() * 3 + 1; // Random size between 1px and 4px
            mote.style.width = `${size}px`; 
            mote.style.height = `${size}px`;
            mote.style.left = `${Math.random() * 100}%`; // Random horizontal position
            mote.style.top = `${Math.random() * 100}%`; // Random vertical position
            mote.style.animationDuration = `${Math.random() * 20 + 15}s`; // Random animation duration
            mote.style.animationDelay = `${Math.random() * 10}s`; // Random animation delay
            // Custom CSS properties for animation keyframes
            mote.style.setProperty('--x-end', Math.random() * 200 - 100); 
            mote.style.setProperty('--y-end', Math.random() * 200 - 100);
            motesContainer.appendChild(mote);
        }

        // --- BREATHING FOCUS MODE LOGIC ---
        /**
         * Toggles the breathing focus mode on and off.
         */
        function toggleFocusMode() {
            isFocusModeActive = !isFocusModeActive;
            body.classList.toggle('focus-mode-active', isFocusModeActive);
            focusToggleButton.classList.toggle('active', isFocusModeActive);

            if (isFocusModeActive) {
                // --- Activate Focus Mode ---
                breathIndex = 0; // Reset breath prompt index
                
                /**
                 * Updates the breathing prompt text and controls mote animation.
                 */
                const updatePrompt = () => {
                    focusPromptEl.style.opacity = '0'; // Fade out current prompt
                    setTimeout(() => {
                        const currentPrompt = breathPrompts[breathIndex];
                        focusPromptEl.textContent = currentPrompt; // Set new prompt
                        focusPromptEl.style.opacity = '1'; // Fade in new prompt

                        // Pause motes during "Hold" phases
                        motesContainer.classList.toggle('is-holding', currentPrompt === "Hold");

                        // Move to the next prompt
                        breathIndex = (breathIndex + 1) % breathPrompts.length;
                    }, 500); // Wait for fade out transition (matching CSS)
                };
                
                updatePrompt(); // Initial call to display first prompt
                focusInterval = setInterval(updatePrompt, 4000); // Cycle prompts every 4 seconds
            } else {
                // --- Deactivate Focus Mode ---
                if (focusInterval) {
                    clearInterval(focusInterval); // Stop the breathing prompt interval
                }
                focusInterval = null;
                motesContainer.classList.remove('is-holding'); // Resume mote animation
                focusPromptEl.style.opacity = '0'; // Fade out current prompt
                setTimeout(() => {
                    focusPromptEl.textContent = originalPromptText; // Restore original prompt
                    focusPromptEl.style.opacity = '1'; // Fade in original prompt
                }, 500); // Wait for fade out transition
            }
        }
        
        // Event listener for focus mode toggle button
        focusToggleButton.addEventListener('click', toggleFocusMode);

        // Allow clicking anywhere on the background to exit focus mode
        document.getElementById('background-canvas').addEventListener('click', () => {
            if (isFocusModeActive) {
                toggleFocusMode();
            }
        });

        // Initial setup: Set active state for the current theme on load
        updateControlActiveStates();
    });
    </script>
</body>
</html>

